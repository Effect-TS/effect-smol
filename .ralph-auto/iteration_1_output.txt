{"type":"step_start","timestamp":1768774422991,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bd1ce001jNn2laL7j22xTc","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bc70800152xXpUQJ0EUpsm","type":"step-start","snapshot":"2ede277e58b2142a4fe83ffb546ed178bc9d7360"}}
{"type":"tool_use","timestamp":1768774423971,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bd307001V2EDB1DMfeEH0u","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bc70800152xXpUQJ0EUpsm","type":"tool","callID":"toolu_01Kz1Y2ZZD97kosKu2YoAJCj","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.specs/AI_ERROR_DOMAIN_MODEL.md"},"output":"<file>\n00001| # AI Error Domain Model\n00002| \n00003| **Status: DRAFT**\n00004| \n00005| ## Overview\n00006| \n00007| Replace the current `AiError` design with a comprehensive, provider-agnostic domain model for errors originating from large language model providers. The new design uses the `reason` pattern (see `Effect.catchReason`) where `AiError` is a top-level wrapper error containing `module`, `method`, and a `reason` field that holds the semantic error.\n00008| \n00009| ## Problem Statement / Motivation\n00010| \n00011| ### Current Limitations\n00012| \n00013| 1. **Transport-centric errors**: Current errors (`HttpRequestError`, `HttpResponseError`) focus on HTTP mechanics, not AI-specific failure modes\n00014| 2. **Missing semantic categories**: No distinction between rate limiting, quota exhaustion, content policy violations, model availability, etc.\n00015| 3. **Poor retry guidance**: Errors don't indicate whether retrying is appropriate or provide backoff hints\n00016| 4. **Limited provider context**: No structured way to capture provider-specific error codes or metadata\n00017| 5. **No cost/usage context**: Errors don't capture token usage or cost information when available\n00018| 6. **Weak recoverability signals**: Callers can't easily determine if an error is transient vs permanent\n00019| 7. **Bad naming**: `MalformedInput` is unclear and doesn't convey semantic meaning\n00020| \n00021| ### Goals\n00022| \n00023| - **Semantic error categories** that map to LLM-specific failure modes\n00024| - **Provider-agnostic** design that works across OpenAI, Anthropic, Google, etc.\n00025| - **Rich context** including retry hints, provider error codes, usage data\n00026| - **Recoverability classification** (transient vs permanent)\n00027| - **Actionable error messages** with specific remediation guidance\n00028| - **Leverage `reason` pattern** for ergonomic error handling via `Effect.catchReason`\n00029| \n00030| ## Design Decisions\n00031| \n00032| ### 1. Schema.ErrorClass with `_tag` via Schema.tag\n00033| \n00034| All errors use `Schema.ErrorClass` with `_tag` defined via `Schema.tag(\"...\")`:\n00035| \n00036| ```typescript\n00037| export class RateLimitError extends Schema.ErrorClass<RateLimitError>(\n00038|   \"effect/ai/AiError/RateLimitError\"\n00039| )({\n00040|   _tag: Schema.tag(\"RateLimitError\")\n00041|   // ... fields\n00042| }) {}\n00043| ```\n00044| \n00045| ### 2. `reason` Pattern with Top-Level AiError\n00046| \n00047| Use the `reason` pattern recently introduced in Effect (see `Effect.catchReason`, `Effect.unwrapReason`). `AiError` is the top-level error with `module`, `method`, and `reason`:\n00048| \n00049| ```typescript\n00050| class AiError extends Schema.ErrorClass<AiError>(\"effect/ai/AiError\")({\n00051|   _tag: Schema.tag(\"AiError\"),\n00052|   module: Schema.String,\n00053|   method: Schema.String,\n00054|   reason: AiErrorReason // Union of all semantic error types\n00055| }) {}\n00056| ```\n00057| \n00058| This enables:\n00059| \n00060| ```typescript\n00061| // Handle specific reason types\n00062| program.pipe(\n00063|   Effect.catchReason(\"AiError\", \"RateLimitError\", (reason) => Effect.succeed(`Retry after ${reason.retryAfter}`))\n00064| )\n00065| \n00066| // Handle multiple reasons\n00067| program.pipe(\n00068|   Effect.catchReasons(\"AiError\", {\n00069|     RateLimitError: (r) => Effect.succeed(`Retry after ${r.retryAfter}`),\n00070|     QuotaExhaustedError: (r) => Effect.fail(new BillingError())\n00071|   })\n00072| )\n00073| \n00074| // Unwrap reason to error channel\n00075| program.pipe(Effect.unwrapReason(\"AiError\"))\n00076| // Effect<A, AiError> -> Effect<A, RateLimitError | QuotaExhaustedError | ...>\n00077| ```\n00078| \n00079| ### 3. Provider-Specific Mapping in Provider Packages\n00080| \n00081| Provider-specific error mapping (e.g., OpenAI error codes -> semantic reasons) lives in provider packages, not in the core `AiError` module. The core module provides:\n00082| \n00083| - Semantic reason types\n00084| - Base `AiError` wrapper\n00085| - Generic HTTP -> reason mapping utilities\n00086| \n00087| Provider packages implement:\n00088| \n00089| - Provider-specific error code mapping\n00090| - Custom reason construction from provider responses\n00091| \n00092| ### 4. Semantic Error Categories\n00093| \n00094| Map provider errors to semantic categories:\n00095| \n00096| - `RateLimitError` - Request throttled (429s, provider-specific limits)\n00097| - `QuotaExhaustedError` - Account/billing limits reached\n00098| - `AuthenticationError` - Invalid/expired credentials\n00099| - `ContentPolicyError` - Input/output violated content policy\n00100| - `ModelUnavailableError` - Model not available/deprecated\n00101| - `ContextLengthError` - Token limit exceeded\n00102| - `InvalidRequestError` - Malformed request parameters (replaces `MalformedInput`)\n00103| - `ProviderInternalError` - Provider-side failures (5xx)\n00104| - `TimeoutError` - Request timeout (no streaming-specific types)\n00105| - `NetworkError` - Transport-level failures\n00106| - `OutputParseError` - LLM output parsing failures\n00107| - `UnknownError` - Catch-all\n00108| \n00109| ### 5. Recoverability Classification\n00110| \n00111| Each reason has an `isRetryable` getter that computes retryability based on the error state:\n00112| \n00113| ```typescript\n00114| get isRetryable(): boolean {\n00115|   return true  // or computed based on error properties\n00116| }\n00117| readonly retryAfter?: Duration  // Effect Duration type, when retry is recommended\n00118| ```\n00119| \n00120| This approach:\n00121| \n00122| - Avoids redundant stored state\n00123| - Allows retryability to be computed from other fields (e.g., `ModelUnavailableError` is retryable only if `kind` is `\"Overloaded\"` or `\"Maintenance\"`)\n00124| - Keeps the schema simpler (no need for `Schema.Literal(true).withDefault()`)\n00125| \n00126| ### 6. ContentPolicyError Includes Flagged Content\n00127| \n00128| When available, include the flagged content for debugging:\n00129| \n00130| ```typescript\n00131| flaggedContent: Schema.optional(Schema.String) // The actual content that was flagged\n00132| ```\n00133| \n00134| ### 7. No Streaming-Specific Error Types\n00135| \n00136| Streaming errors map to existing reason types:\n00137| \n00138| - Stream timeout -> `TimeoutError`\n00139| - Stream interrupted -> `NetworkError`\n00140| - Partial response -> `OutputParseError` or `ProviderInternalError`\n00141| \n00142| ## Technical Details\n00143| \n00144| ### Top-Level AiError\n00145| \n00146| ```typescript\n00147| const TypeId = \"~effect/unstable/ai/AiError\" as const\n00148| \n00149| export class AiError extends Schema.ErrorClass<AiError>(\"effect/ai/AiError\")({\n00150|   _tag: Schema.tag(\"AiError\"),\n00151|   module: Schema.String,\n00152|   method: Schema.String,\n00153|   reason: AiErrorReason\n00154| }) {\n00155|   readonly [TypeId] = TypeId\n00156| \n00157|   /**\n00158|    * Delegates to the underlying reason's isRetryable getter.\n00159|    */\n00160|   get isRetryable(): boolean {\n00161|     return this.reason.isRetryable\n00162|   }\n00163| \n00164|   /**\n00165|    * Delegates to the underlying reason's retryAfter if present.\n00166|    */\n00167|   get retryAfter(): Duration | undefined {\n00168|     return \"retryAfter\" in this.reason ? this.reason.retryAfter : undefined\n00169|   }\n00170| \n00171|   override get message(): string {\n00172|     return `${this.module}.${this.method}: ${this.reason.message}`\n00173|   }\n00174| }\n00175| \n00176| export const isAiError = (u: unknown): u is AiError => Predicate.hasProperty(u, TypeId)\n00177| ```\n00178| \n00179| ### Reason Type Definitions\n00180| \n00181| #### RateLimitError\n00182| \n00183| ```typescript\n00184| export class RateLimitError extends Schema.ErrorClass<RateLimitError>(\n00185|   \"effect/ai/AiError/RateLimitError\"\n00186| )({\n00187|   _tag: Schema.tag(\"RateLimitError\"),\n00188|   retryAfter: Schema.optional(Schema.Duration),\n00189|   limit: Schema.optional(Schema.String), // \"requests\" | \"tokens\" | etc.\n00190|   remaining: Schema.optional(Schema.Number),\n00191|   resetAt: Schema.optional(Schema.DateTimeUtc),\n00192|   provider: Schema.optional(ProviderMetadata),\n00193|   http: Schema.optional(HttpContext),\n00194|   cause: Schema.optional(Schema.Defect)\n00195| }) {\n00196|   get isRetryable(): boolean {\n00197|     return true\n00198|   }\n00199| \n00200|   override get message(): string {\n00201|     let msg = `Rate limit exceeded`\n00202|     if (this.limit) msg += ` (${this.limit})`\n00203|     if (this.retryAfter) msg += `. Retry after ${Duration.format(this.retryAfter)}`\n00204|     return msg\n00205|   }\n00206| }\n00207| ```\n00208| \n00209| #### QuotaExhaustedError\n00210| \n00211| ```typescript\n00212| export class QuotaExhaustedError extends Schema.ErrorClass<QuotaExhaustedError>(\n00213|   \"effect/ai/AiError/QuotaExhaustedError\"\n00214| )({\n00215|   _tag: Schema.tag(\"QuotaExhaustedError\"),\n00216|   quotaType: Schema.optional(Schema.String), // \"tokens\" | \"requests\" | \"spend\"\n00217|   resetAt: Schema.optional(Schema.DateTimeUtc),\n00218|   provider: Schema.optional(ProviderMetadata),\n00219|   http: Schema.optional(HttpContext),\n00220|   cause: Schema.optional(Schema.Defect)\n00221| }) {\n00222|   get isRetryable(): boolean {\n00223|     return false\n00224|   }\n00225| \n00226|   override get message(): string {\n00227|     let msg = `Quota exhausted`\n00228|     if (this.quotaType) msg += ` (${this.quotaType})`\n00229|     if (this.resetAt) msg += `. Resets at ${this.resetAt}`\n00230|     return `${msg}. Check your account billing and usage limits.`\n00231|   }\n00232| }\n00233| ```\n00234| \n00235| #### AuthenticationError\n00236| \n00237| ```typescript\n00238| export class AuthenticationError extends Schema.ErrorClass<AuthenticationError>(\n00239|   \"effect/ai/AiError/AuthenticationError\"\n00240| )({\n00241|   _tag: Schema.tag(\"AuthenticationError\"),\n00242|   kind: Schema.Literals([\"InvalidKey\", \"ExpiredKey\", \"MissingKey\", \"InsufficientPermissions\", \"Unknown\"]),\n00243|   provider: Schema.optional(ProviderMetadata),\n00244|   http: Schema.optional(HttpContext),\n00245|   cause: Schema.optional(Schema.Defect)\n00246| }) {\n00247|   get isRetryable(): boolean {\n00248|     return false\n00249|   }\n00250| \n00251|   override get message(): string {\n00252|     const suggestions: Record<string, string> = {\n00253|       InvalidKey: \"Verify your API key is correct\",\n00254|       ExpiredKey: \"Your API key has expired. Generate a new one\",\n00255|       MissingKey: \"No API key provided. Set the appropriate environment variable\",\n00256|       InsufficientPermissions: \"Your API key lacks required permissions\",\n00257|       Unknown: \"Authentication failed. Check your credentials\"\n00258|     }\n00259|     return `${this.kind}: ${suggestions[this.kind]}`\n00260|   }\n00261| }\n00262| ```\n00263| \n00264| #### ContentPolicyError\n00265| \n00266| ```typescript\n00267| export class ContentPolicyError extends Schema.ErrorClass<ContentPolicyError>(\n00268|   \"effect/ai/AiError/ContentPolicyError\"\n00269| )({\n00270|   _tag: Schema.tag(\"ContentPolicyError\"),\n00271|   violationType: Schema.optional(Schema.String), // \"hate\" | \"violence\" | etc.\n00272|   flaggedInput: Schema.optional(Schema.Boolean), // true if input was flagged\n00273|   flaggedOutput: Schema.optional(Schema.Boolean), // true if output was flagged\n00274|   flaggedContent: Schema.optional(Schema.String), // actual content that was flagged\n00275|   categories: Schema.optional(Schema.Array(Schema.String)),\n00276|   provider: Schema.optional(ProviderMetadata),\n00277|   http: Schema.optional(HttpContext),\n00278|   cause: Schema.optional(Schema.Defect)\n00279| }) {\n00280|   get isRetryable(): boolean {\n00281|     return false\n00282|   }\n00283| \n00284|   override get message(): string {\n00285|     let msg = `Content policy violation`\n00286|     if (this.violationType) msg += `: ${this.violationType}`\n00287|     if (this.flaggedInput) msg += ` in input`\n00288|     if (this.flaggedOutput) msg += ` in output`\n00289|     return msg\n00290|   }\n00291| }\n00292| ```\n00293| \n00294| #### ModelUnavailableError\n00295| \n00296| ```typescript\n00297| export class ModelUnavailableError extends Schema.ErrorClass<ModelUnavailableError>(\n00298|   \"effect/ai/AiError/ModelUnavailableError\"\n00299| )({\n00300|   _tag: Schema.tag(\"ModelUnavailableError\"),\n00301|   model: Schema.String,\n00302|   kind: Schema.Literals([\"NotFound\", \"Deprecated\", \"Overloaded\", \"Maintenance\", \"Unknown\"]),\n00303|   alternativeModels: Schema.optional(Schema.Array(Schema.String)),\n00304|   provider: Schema.optional(ProviderMetadata),\n00305|   http: Schema.optional(HttpContext),\n00306|   cause: Schema.optional(Schema.Defect)\n00307| }) {\n00308|   get isRetryable(): boolean {\n00309|     // Retryable only for temporary conditions\n00310|     return this.kind === \"Overloaded\" || this.kind === \"Maintenance\"\n00311|   }\n00312| \n00313|   override get message(): string {\n00314|     let msg = `Model '${this.model}' unavailable: ${this.kind}`\n00315|     if (this.alternativeModels && this.alternativeModels.length > 0) {\n00316|       msg += `. Try: ${this.alternativeModels.join(\", \")}`\n00317|     }\n00318|     return msg\n00319|   }\n00320| }\n00321| ```\n00322| \n00323| #### ContextLengthError\n00324| \n00325| ```typescript\n00326| export class ContextLengthError extends Schema.ErrorClass<ContextLengthError>(\n00327|   \"effect/ai/AiError/ContextLengthError\"\n00328| )({\n00329|   _tag: Schema.tag(\"ContextLengthError\"),\n00330|   maxTokens: Schema.optional(Schema.Number),\n00331|   requestedTokens: Schema.optional(Schema.Number),\n00332|   provider: Schema.optional(ProviderMetadata),\n00333|   http: Schema.optional(HttpContext),\n00334|   cause: Schema.optional(Schema.Defect)\n00335| }) {\n00336|   get isRetryable(): boolean {\n00337|     return false // Requires reducing input, not just retrying\n00338|   }\n00339| \n00340|   override get message(): string {\n00341|     let msg = `Context length exceeded`\n00342|     if (this.requestedTokens && this.maxTokens) {\n00343|       msg += `: requested ${this.requestedTokens} tokens, max ${this.maxTokens}`\n00344|     }\n00345|     return `${msg}. Reduce input size or use a model with larger context window.`\n00346|   }\n00347| }\n00348| ```\n00349| \n00350| #### InvalidRequestError\n00351| \n00352| Replaces `MalformedInput` with clearer naming.\n00353| \n00354| ```typescript\n00355| export class InvalidRequestError extends Schema.ErrorClass<InvalidRequestError>(\n00356|   \"effect/ai/AiError/InvalidRequestError\"\n00357| )({\n00358|   _tag: Schema.tag(\"InvalidRequestError\"),\n00359|   parameter: Schema.optional(Schema.String),\n00360|   constraint: Schema.optional(Schema.String),\n00361|   description: Schema.optional(Schema.String),\n00362|   provider: Schema.optional(ProviderMetadata),\n00363|   http: Schema.optional(HttpContext),\n00364|   cause: Schema.optional(Schema.Defect)\n00365| }) {\n00366|   get isRetryable(): boolean {\n00367|     return false // Invalid requests need to be fixed, not retried\n00368|   }\n00369| \n00370|   override get message(): string {\n00371|     let msg = `Invalid request`\n00372|     if (this.parameter) msg += `: parameter '${this.parameter}'`\n00373|     if (this.constraint) msg += ` ${this.constraint}`\n00374|     if (this.description) msg += `. ${this.description}`\n00375|     return msg\n00376|   }\n00377| }\n00378| ```\n00379| \n00380| #### ProviderInternalError\n00381| \n00382| ```typescript\n00383| export class ProviderInternalError extends Schema.ErrorClass<ProviderInternalError>(\n00384|   \"effect/ai/AiError/ProviderInternalError\"\n00385| )({\n00386|   _tag: Schema.tag(\"ProviderInternalError\"),\n00387|   retryAfter: Schema.optional(Schema.Duration),\n00388|   provider: Schema.optional(ProviderMetadata),\n00389|   http: Schema.optional(HttpContext),\n00390|   cause: Schema.optional(Schema.Defect)\n00391| }) {\n00392|   get isRetryable(): boolean {\n00393|     return true // Provider errors are typically transient\n00394|   }\n00395| \n00396|   override get message(): string {\n00397|     let msg = `Provider internal error`\n00398|     if (this.provider?.name) msg = `${this.provider.name} internal error`\n00399|     if (this.retryAfter) msg += `. Retry after ${Duration.format(this.retryAfter)}`\n00400|     return `${msg}. This is likely temporary.`\n00401|   }\n00402| }\n00403| ```\n00404| \n00405| #### TimeoutError\n00406| \n00407| ```typescript\n00408| export class TimeoutError extends Schema.ErrorClass<TimeoutError>(\n00409|   \"effect/ai/AiError/TimeoutError\"\n00410| )({\n00411|   _tag: Schema.tag(\"TimeoutError\"),\n00412|   phase: Schema.Literals([\"Connection\", \"Request\", \"Response\"]),\n00413|   duration: Schema.optional(Schema.Duration),\n00414|   provider: Schema.optional(ProviderMetadata),\n00415|   http: Schema.optional(HttpContext),\n00416|   cause: Schema.optional(Schema.Defect)\n00417| }) {\n00418|   get isRetryable(): boolean {\n00419|     return true // Timeouts are typically transient\n00420|   }\n00421| \n00422|   override get message(): string {\n00423|     let msg = `${this.phase} timeout`\n00424|     if (this.duration) msg += ` after ${Duration.format(this.duration)}`\n00425|     return msg\n00426|   }\n00427| }\n00428| ```\n00429| \n00430| #### NetworkError\n00431| \n00432| ```typescript\n00433| export class NetworkError extends Schema.ErrorClass<NetworkError>(\n00434|   \"effect/ai/AiError/NetworkError\"\n00435| )({\n00436|   _tag: Schema.tag(\"NetworkError\"),\n00437|   kind: Schema.Literals([\"ConnectionRefused\", \"DnsLookupFailed\", \"TlsError\", \"Unknown\"]),\n00438|   http: Schema.optional(HttpContext),\n00439|   cause: Schema.optional(Schema.Defect)\n00440| }) {\n00441|   get isRetryable(): boolean {\n00442|     return true // Network errors are typically transient\n00443|   }\n00444| \n00445|   override get message(): string {\n00446|     const suggestions: Record<string, string> = {\n00447|       ConnectionRefused: \"Check network connectivity and firewall settings\",\n00448|       DnsLookupFailed: \"Verify the API endpoint hostname is correct\",\n00449|       TlsError: \"TLS/SSL handshake failed. Check certificate validity\",\n00450|       Unknown: \"Network error occurred. Check your connection\"\n00451|     }\n00452|     return `${this.kind}: ${suggestions[this.kind]}`\n00453|   }\n00454| }\n00455| ```\n00456| \n00457| #### OutputParseError\n00458| \n00459| ```typescript\n00460| export class OutputParseError extends Schema.ErrorClass<OutputParseError>(\n00461|   \"effect/ai/AiError/OutputParseError\"\n00462| )({\n00463|   _tag: Schema.tag(\"OutputParseError\"),\n00464|   rawOutput: Schema.optional(Schema.String),\n00465|   expectedSchema: Schema.optional(Schema.String),\n00466|   provider: Schema.optional(ProviderMetadata),\n00467|   usage: Schema.optional(UsageInfo),\n00468|   cause: Schema.optional(Schema.Defect)\n00469| }) {\n00470|   get isRetryable(): boolean {\n00471|     return true // LLM outputs are non-deterministic, retry often works\n00472|   }\n00473| \n00474|   static fromSchemaError(params: {\n00475|     readonly rawOutput?: string\n00476|     readonly error: Schema.SchemaError\n00477|   }): OutputParseError {\n00478|     return new OutputParseError({\n00479|       rawOutput: params.rawOutput,\n00480|       cause: params.error\n00481|     })\n00482|   }\n00483| \n00484|   override get message(): string {\n00485|     return `Failed to parse LLM output into expected schema`\n00486|   }\n00487| }\n00488| ```\n00489| \n00490| #### UnknownError\n00491| \n00492| ```typescript\n00493| export class UnknownError extends Schema.ErrorClass<UnknownError>(\n00494|   \"effect/ai/AiError/UnknownError\"\n00495| )({\n00496|   _tag: Schema.tag(\"UnknownError\"),\n00497|   description: Schema.optional(Schema.String),\n00498|   provider: Schema.optional(ProviderMetadata),\n00499|   http: Schema.optional(HttpContext),\n00500|   cause: Schema.optional(Schema.Defect)\n00501| }) {\n00502|   get isRetryable(): boolean {\n00503|     return false // Unknown errors are not safe to retry by default\n00504|   }\n00505| \n00506|   override get message(): string {\n00507|     return this.description ?? `Unknown error`\n00508|   }\n00509| }\n00510| ```\n00511| \n00512| ### Supporting Schemas\n00513| \n00514| ```typescript\n00515| export const ProviderMetadata = Schema.Struct({\n00516|   name: Schema.String,\n00517|   errorCode: Schema.optional(Schema.String),\n00518|   errorType: Schema.optional(Schema.String),\n00519|   requestId: Schema.optional(Schema.String),\n00520|   raw: Schema.optional(Schema.Unknown)\n00521| }).annotate({ identifier: \"ProviderMetadata\" })\n00522| \n00523| export const HttpRequestDetails = Schema.Struct({\n00524|   method: Schema.Literals([\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\"]),\n00525|   url: Schema.String,\n00526|   urlParams: Schema.Array(Schema.Tuple([Schema.String, Schema.String])),\n00527|   hash: Schema.optional(Schema.String),\n00528|   headers: Schema.Record(Schema.String, Schema.String)\n00529| }).annotate({ identifier: \"HttpRequestDetails\" })\n00530| \n00531| export const HttpResponseDetails = Schema.Struct({\n00532|   status: Schema.Number,\n00533|   headers: Schema.Record(Schema.String, Schema.String)\n00534| }).annotate({ identifier: \"HttpResponseDetails\" })\n00535| \n00536| export const HttpContext = Schema.Struct({\n00537|   request: HttpRequestDetails,\n00538|   response: Schema.optional(HttpResponseDetails),\n00539|   body: Schema.optional(Schema.String)\n00540| }).annotate({ identifier: \"HttpContext\" })\n00541| \n00542| export const UsageInfo = Schema.Struct({\n00543|   promptTokens: Schema.optional(Schema.Number),\n00544|   completionTokens: Schema.optional(Schema.Number),\n00545|   totalTokens: Schema.optional(Schema.Number)\n00546| }).annotate({ identifier: \"UsageInfo\" })\n00547| ```\n00548| \n00549| ### Reason Union Type\n00550| \n00551| ```typescript\n00552| export type AiErrorReason =\n00553|   | RateLimitError\n00554|   | QuotaExhaustedError\n00555|   | AuthenticationError\n00556|   | ContentPolicyError\n00557|   | ModelUnavailableError\n00558|   | ContextLengthError\n00559|   | InvalidRequestError\n00560|   | ProviderInternalError\n00561|   | TimeoutError\n00562|   | NetworkError\n00563|   | OutputParseError\n00564|   | UnknownError\n00565| \n00566| export const AiErrorReason: Schema.Union<[\n00567|   typeof RateLimitError,\n00568|   typeof QuotaExhaustedError,\n00569|   typeof AuthenticationError,\n00570|   typeof ContentPolicyError,\n00571|   typeof ModelUnavailableError,\n00572|   typeof ContextLengthError,\n00573|   typeof InvalidRequestError,\n00574|   typeof ProviderInternalError,\n00575|   typeof TimeoutError,\n00576|   typeof NetworkError,\n00577|   typeof OutputParseError,\n00578|   typeof UnknownError\n00579| ]> = Schema.Union([\n00580|   RateLimitError,\n00581|   QuotaExhaustedError,\n00582|   AuthenticationError,\n00583|   ContentPolicyError,\n00584|   ModelUnavailableError,\n00585|   ContextLengthError,\n00586|   InvalidRequestError,\n00587|   ProviderInternalError,\n00588|   TimeoutError,\n00589|   NetworkError,\n00590|   OutputParseError,\n00591|   UnknownError\n00592| ])\n00593| ```\n00594| \n00595| ### Utility Functions (Core Module)\n00596| \n00597| ```typescript\n00598| /**\n00599|  * Creates an AiError with the given reason.\n00600|  */\n00601| export const make = (params: {\n00602|   readonly module: string\n00603|   readonly method: string\n00604|   readonly reason: AiErrorReason\n00605| }): AiError => new AiError(params)\n00606| \n00607| /**\n00608|  * Base HTTP status code to reason mapping.\n00609|  * Provider packages can extend this for provider-specific codes.\n00610|  */\n00611| export const reasonFromHttpStatus = (params: {\n00612|   readonly status: number\n00613|   readonly body?: unknown\n00614|   readonly http?: typeof HttpContext.Type\n00615|   readonly provider?: typeof ProviderMetadata.Type\n00616| }): AiErrorReason => {\n00617|   const { status, body, http, provider } = params\n00618|   switch (status) {\n00619|     case 400:\n00620|       return new InvalidRequestError({ http, provider, cause: body })\n00621|     case 401:\n00622|       return new AuthenticationError({ kind: \"InvalidKey\", http, provider, cause: body })\n00623|     case 403:\n00624|       return new AuthenticationError({ kind: \"InsufficientPermissions\", http, provider, cause: body })\n00625|     case 408:\n00626|       return new TimeoutError({ phase: \"Request\", http, provider, cause: body })\n00627|     case 429:\n00628|       return new RateLimitError({ http, provider, cause: body })\n00629|     default:\n00630|       if (status >= 500) {\n00631|         return new ProviderInternalError({ http, provider, cause: body })\n00632|       }\n00633|       return new UnknownError({ http, provider, cause: body })\n00634|   }\n00635| }\n00636| ```\n00637| \n00638| ## Implementation Phases\n00639| \n00640| ### Phase 1: Supporting Schemas\n00641| \n00642| **Goal**: Define foundational schemas for metadata and context.\n00643| \n00644| **Files to modify**:\n00645| \n00646| - `packages/effect/src/unstable/ai/AiError.ts`\n00647| \n00648| **Tasks**:\n00649| \n00650| - [ ] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n00651| - [ ] **1.2** Add `UsageInfo` schema with token count fields\n00652| - [ ] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n00653| - [ ] **1.4** Keep existing `HttpResponseDetails` schema\n00654| - [ ] **1.5** Add `HttpContext` schema combining request/response/body\n00655| - [ ] **1.6** Run `pnpm lint-fix`\n00656| - [ ] **1.7** Run `pnpm check`\n00657| \n00658| **Verification**: `pnpm check` passes\n00659| \n00660| ### Phase 2: Reason Classes (Part 1)\n00661| \n00662| **Goal**: Implement first batch of semantic reason types.\n00663| \n00664| **Files to modify**:\n00665| \n00666| - `packages/effect/src/unstable/ai/AiError.ts`\n00667| \n00668| **Tasks**:\n00669| \n00670| - [ ] **2.1** Create `RateLimitError` with `isRetryable` getter (returns `true`), `retryAfter: Duration`, `limit`, `remaining`, `resetAt`\n00671| - [ ] **2.2** Create `QuotaExhaustedError` with `isRetryable` getter (returns `false`), `quotaType`, `resetAt`\n00672| - [ ] **2.3** Create `AuthenticationError` with `isRetryable` getter (returns `false`), `kind` discriminant\n00673| - [ ] **2.4** Create `ContentPolicyError` with `isRetryable` getter (returns `false`), `violationType`, `flaggedInput`, `flaggedOutput`, `flaggedContent`, `categories`\n00674| - [ ] **2.5** Create `ModelUnavailableError` with `isRetryable` getter (computed from `kind`), `model`, `kind`, `alternativeModels`\n00675| - [ ] **2.6** Create `ContextLengthError` with `isRetryable` getter (returns `false`), `maxTokens`, `requestedTokens`\n00676| - [ ] **2.7** Run `pnpm lint-fix`\n00677| - [ ] **2.8** Run `pnpm check`\n00678| \n00679| **Verification**: `pnpm check` passes\n00680| \n00681| ### Phase 3: Reason Classes (Part 2)\n00682| \n00683| **Goal**: Implement remaining reason types.\n00684| \n00685| **Files to modify**:\n00686| \n00687| - `packages/effect/src/unstable/ai/AiError.ts`\n00688| \n00689| **Tasks**:\n00690| \n00691| - [ ] **3.1** Create `InvalidRequestError` with `isRetryable` getter (returns `false`), `parameter`, `constraint`, `description`\n00692| - [ ] **3.2** Create `ProviderInternalError` with `isRetryable` getter (returns `true`), `retryAfter: Duration`\n00693| - [ ] **3.3** Create `TimeoutError` with `isRetryable` getter (returns `true`), `phase` discriminant, `duration: Duration`\n00694| - [ ] **3.4** Create `NetworkError` with `isRetryable` getter (returns `true`), `kind` discriminant\n00695| - [ ] **3.5** Create `OutputParseError` with `isRetryable` getter (returns `true`), `rawOutput`, `expectedSchema`, `fromSchemaError` static method\n00696| - [ ] **3.6** Create `UnknownError` with `isRetryable` getter (returns `false`), `description`\n00697| - [ ] **3.7** Run `pnpm lint-fix`\n00698| - [ ] **3.8** Run `pnpm check`\n00699| \n00700| **Verification**: `pnpm check` passes\n00701| \n00702| ### Phase 4: AiErrorReason Union & Top-Level AiError\n00703| \n00704| **Goal**: Create reason union and top-level AiError wrapper.\n00705| \n00706| **Files to modify**:\n00707| \n00708| - `packages/effect/src/unstable/ai/AiError.ts`\n00709| \n00710| **Tasks**:\n00711| \n00712| - [ ] **4.1** Create `AiErrorReason` type union of all reason types\n00713| - [ ] **4.2** Create `AiErrorReason` schema union\n00714| - [ ] **4.3** Create top-level `AiError` class with `module`, `method`, `reason: AiErrorReason`, `isRetryable` getter, `retryAfter` getter\n00715| - [ ] **4.4** Implement `make` constructor function\n00716| - [ ] **4.5** Implement `reasonFromHttpStatus` utility function\n00717| - [ ] **4.6** Update `isAiError` type guard\n00718| - [ ] **4.7** Run `pnpm lint-fix`\n00719| - [ ] **4.8** Run `pnpm check`\n00720| \n00721| **Verification**: `pnpm check` passes\n00722| \n00723| ### Phase 5: Remove Deprecated Types & Update Consumers\n00724| \n00725| **Goal**: Remove old error types and update consumers to use new design.\n00726| \n00727| **Files to modify**:\n00728| \n00729| - `packages/effect/src/unstable/ai/AiError.ts`\n00730| - `packages/effect/src/unstable/ai/LanguageModel.ts`\n00731| - `packages/effect/src/unstable/ai/Toolkit.ts`\n00732| \n00733| **Tasks**:\n00734| \n00735| - [ ] **5.1** Remove `HttpRequestError` class\n00736| - [ ] **5.2** Remove `HttpResponseError` class\n00737| - [ ] **5.3** Remove `MalformedInput` class (replaced by `InvalidRequestError`)\n00738| - [ ] **5.4** Remove `MalformedOutput` class (replaced by `OutputParseError`)\n00739| - [ ] **5.5** Remove old `UnknownError` class\n00740| - [ ] **5.6** Update `LanguageModel.ts` to use new `AiError` with `reason`\n00741| - [ ] **5.7** Update `Toolkit.ts` to use new `AiError` with `reason`\n00742| - [ ] **5.8** Update `isAiError` checks throughout codebase\n00743| - [ ] **5.9** Run `pnpm lint-fix`\n00744| - [ ] **5.10** Run `pnpm check`\n00745| \n00746| **Verification**: `pnpm check` passes\n00747| \n00748| ### Phase 6: Tests\n00749| \n00750| **Goal**: Comprehensive test coverage for all error types.\n00751| \n00752| **Files to create/modify**:\n00753| \n00754| - `packages/effect/test/unstable/ai/AiError.test.ts`\n00755| \n00756| **Tasks**:\n00757| \n00758| - [ ] **6.1** Test `AiError` construction with each reason type\n00759| - [ ] **6.2** Test message generation for `AiError` and each reason\n00760| - [ ] **6.3** Test `isRetryable` getter returns correct value for each reason type\n00761| - [ ] **6.4** Test `AiError.isRetryable` delegates to reason's `isRetryable`\n00762| - [ ] **6.5** Test `AiError.retryAfter` delegates to reason's `retryAfter` when present\n00763| - [ ] **6.6** Test `Effect.catchReason(\"AiError\", \"<reason>\", ...)` for all reasons\n00764| - [ ] **6.7** Test `Effect.catchReasons(\"AiError\", {...})` with multiple handlers\n00765| - [ ] **6.8** Test `Effect.unwrapReason(\"AiError\")` promotes reason to error channel\n00766| - [ ] **6.9** Test `reasonFromHttpStatus` mapping\n00767| - [ ] **6.10** Test `OutputParseError.fromSchemaError` static method\n00768| - [ ] **6.11** Test `isAiError` type guard\n00769| - [ ] **6.12** Test schema encoding/decoding roundtrip for all types\n00770| - [ ] **6.13** Run `pnpm test AiError`\n00771| \n00772| **Verification**: All tests pass\n00773| \n00774| ### Phase 7: Documentation & JSDoc\n00775| \n00776| **Goal**: Comprehensive documentation with examples.\n00777| \n00778| **Files to modify**:\n00779| \n00780| - `packages/effect/src/unstable/ai/AiError.ts`\n00781| \n00782| **Tasks**:\n00783| \n00784| - [ ] **7.1** Add module-level JSDoc with overview, `reason` pattern usage, and examples\n00785| - [ ] **7.2** Add JSDoc to `AiError` class with `@example` showing `catchReason` usage\n00786| - [ ] **7.3** Add JSDoc to each reason class with `@example`, `@since`, `@category`\n00787| - [ ] **7.4** Add JSDoc to supporting schemas\n00788| - [ ] **7.5** Add JSDoc to utility functions\n00789| - [ ] **7.6** Run `pnpm docgen` to verify examples compile\n00790| - [ ] **7.7** Run `pnpm lint-fix`\n00791| \n00792| **Verification**: `pnpm docgen` passes\n00793| \n00794| ## Testing Requirements\n00795| \n00796| ### Unit Tests\n00797| \n00798| - Construction of `AiError` with each reason type\n00799| - `isRetryable` getter returns correct value for each reason type\n00800| - `AiError.isRetryable` delegates to reason\n00801| - `AiError.retryAfter` delegates to reason when present\n00802| - Message generation for `AiError` (delegates to reason)\n00803| - Message generation for each reason type\n00804| - Type guard `isAiError`\n00805| \n00806| ### Integration Tests\n00807| \n00808| - `reasonFromHttpStatus` mapping for:\n00809|   - 400 -> `InvalidRequestError`\n00810|   - 401 -> `AuthenticationError` (InvalidKey)\n00811|   - 403 -> `AuthenticationError` (InsufficientPermissions)\n00812|   - 408 -> `TimeoutError`\n00813|   - 429 -> `RateLimitError`\n00814|   - 5xx -> `ProviderInternalError`\n00815| - Schema round-trip encoding/decoding for all types\n00816| \n00817| ### Error Handling Pattern Tests\n00818| \n00819| - `Effect.catchReason(\"AiError\", \"RateLimitError\", handler)` works\n00820| - `Effect.catchReasons(\"AiError\", { ... })` handles multiple reasons\n00821| - `Effect.unwrapReason(\"AiError\")` extracts reason to error channel\n00822| - Effect error channel typing is correct with `reason` pattern\n00823| \n00824| ## Verification Checklist\n00825| \n00826| - [ ] `pnpm lint-fix` passes\n00827| - [ ] `pnpm check` passes\n00828| - [ ] `pnpm test AiError` passes\n00829| - [ ] `pnpm docgen` passes\n00830| - [ ] All errors use `Schema.ErrorClass` with `_tag` via `Schema.tag`\n00831| - [ ] `AiError` has `module`, `method`, `reason` fields\n00832| - [ ] `reason` field is union of all reason types\n00833| - [ ] `Effect.catchReason` / `Effect.catchReasons` / `Effect.unwrapReason` work correctly\n00834| - [ ] `retryAfter` uses `Schema.Duration`\n00835| - [ ] `ContentPolicyError` includes `flaggedContent` field\n00836| - [ ] No streaming-specific error types (use `TimeoutError`, `NetworkError`, etc.)\n00837| - [ ] `MalformedInput` replaced by `InvalidRequestError`\n00838| - [ ] Provider-specific mapping documented as responsibility of provider packages\n00839| - [ ] All reason types have `isRetryable` getter\n00840| - [ ] `AiError` has `isRetryable` and `retryAfter` getters that delegate to reason\n00841| - [ ] All reason types have JSDoc with examples\n00842| \n\n(End of file - total 842 lines)\n</file>","title":".specs/AI_ERROR_DOMAIN_MODEL.md","metadata":{"preview":"# AI Error Domain Model\n\n**Status: DRAFT**\n\n## Overview\n\nReplace the current `AiError` design with a comprehensive, provider-agnostic domain model for errors originating from large language model providers. The new design uses the `reason` pattern (see `Effect.catchReason`) where `AiError` is a top-level wrapper error containing `module`, `method`, and a `reason` field that holds the semantic error.\n\n## Problem Statement / Motivation\n\n### Current Limitations\n\n1. **Transport-centric errors**: Current errors (`HttpRequestError`, `HttpResponseError`) focus on HTTP mechanics, not AI-specific failure modes\n2. **Missing semantic categories**: No distinction between rate limiting, quota exhaustion, content policy violations, model availability, etc.\n3. **Poor retry guidance**: Errors don't indicate whether retrying is appropriate or provide backoff hints\n4. **Limited provider context**: No structured way to capture provider-specific error codes or metadata\n5. **No cost/usage context**: Errors don't capture token usage or cost information when available\n6. **Weak recoverability signals**: Callers can't easily determine if an error is transient vs permanent\n7. **Bad naming**: `MalformedInput` is unclear and doesn't convey semantic meaning\n","truncated":false},"time":{"start":1768774423964,"end":1768774423969}}}}
{"type":"tool_use","timestamp":1768774425252,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bd59e001EPPPEr39cwY6Vd","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bc70800152xXpUQJ0EUpsm","type":"tool","callID":"toolu_01RTqzpjHXxPeUu8TAZbsryV","tool":"bash","state":{"status":"completed","input":{"command":"pnpm check 2>&1 | head -100","description":"Check current CI status"},"output":"\n> @ check /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1\n> tspc -b tsconfig.json\n\n","title":"Check current CI status","metadata":{"output":"\n> @ check /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1\n> tspc -b tsconfig.json\n\n","exit":0,"description":"Check current CI status","truncated":false},"time":{"start":1768774424588,"end":1768774425250}}}}
{"type":"step_finish","timestamp":1768774425290,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bdaa3001KwZgThmrBOpZCR","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bc70800152xXpUQJ0EUpsm","type":"step-finish","reason":"tool-calls","snapshot":"6d3b9c273b116b1123bcd1a477ae2110b10a2255","cost":0,"tokens":{"input":1,"output":162,"reasoning":0,"cache":{"read":13517,"write":2086}}}}
{"type":"step_start","timestamp":1768774427820,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32be4ab001Df1fDeCKlB7XjL","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bdb00001nBP2x4POvFov96","type":"step-start","snapshot":"0d33bf0d269401dde9d45b22208e3bd73c149dd4"}}
{"type":"text","timestamp":1768774428859,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32be4ac001N5iqIjXycXB0MI","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bdb00001nBP2x4POvFov96","type":"text","text":"The CI is green. Let me review the current state of the AiError module to understand what's already implemented:","time":{"start":1768774428856,"end":1768774428856}}}
{"type":"tool_use","timestamp":1768774429327,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32be8bb001ngGM172D4pJ33j","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bdb00001nBP2x4POvFov96","type":"tool","callID":"toolu_019mCWj5qTsG3FTzTkRBMx9G","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts"},"output":"<file>\n00001| /**\n00002|  * The `AiError` module provides comprehensive error handling for AI operations.\n00003|  *\n00004|  * This module defines a hierarchy of error types that can occur when working\n00005|  * with AI services, including HTTP request/response errors, input/output\n00006|  * validation errors, and general runtime errors. All errors follow Effect's\n00007|  * structured error patterns and provide detailed context for debugging.\n00008|  *\n00009|  * ## Error Types\n00010|  *\n00011|  * - **HttpRequestError**: Errors occurring during HTTP request processing\n00012|  * - **HttpResponseError**: Errors occurring during HTTP response processing\n00013|  * - **MalformedInput**: Errors when input data doesn't match expected format\n00014|  * - **MalformedOutput**: Errors when output data can't be parsed or validated\n00015|  * - **UnknownError**: Catch-all for unexpected runtime errors\n00016|  *\n00017|  * @example\n00018|  * ```ts\n00019|  * import { Effect, Match } from \"effect\"\n00020|  * import type { AiError } from \"effect/unstable/ai\"\n00021|  *\n00022|  * const handleAiError = Match.type<AiError.AiError>().pipe(\n00023|  *   Match.tag(\n00024|  *     \"HttpRequestError\",\n00025|  *     (err) => Effect.logError(`Request failed: ${err.message}`)\n00026|  *   ),\n00027|  *   Match.tag(\n00028|  *     \"HttpResponseError\",\n00029|  *     (err) =>\n00030|  *       Effect.logError(`Response error (${err.response.status}): ${err.message}`)\n00031|  *   ),\n00032|  *   Match.tag(\n00033|  *     \"MalformedInput\",\n00034|  *     (err) => Effect.logError(`Invalid input: ${err.message}`)\n00035|  *   ),\n00036|  *   Match.tag(\n00037|  *     \"MalformedOutput\",\n00038|  *     (err) => Effect.logError(`Invalid output: ${err.message}`)\n00039|  *   ),\n00040|  *   Match.orElse((err) => Effect.logError(`Unknown error: ${err.message}`))\n00041|  * )\n00042|  * ```\n00043|  *\n00044|  * @example\n00045|  * ```ts\n00046|  * import { Effect } from \"effect\"\n00047|  * import { AiError } from \"effect/unstable/ai\"\n00048|  *\n00049|  * const aiOperation = Effect.gen(function*() {\n00050|  *   // Some AI operation that might fail\n00051|  *   return yield* new AiError.HttpRequestError({\n00052|  *     module: \"OpenAI\",\n00053|  *     method: \"completion\",\n00054|  *     reason: \"Transport\",\n00055|  *     request: {\n00056|  *       method: \"POST\",\n00057|  *       url: \"https://api.openai.com/v1/completions\",\n00058|  *       urlParams: [],\n00059|  *       hash: undefined,\n00060|  *       headers: { \"Content-Type\": \"application/json\" }\n00061|  *     }\n00062|  *   })\n00063|  * })\n00064|  *\n00065|  * const program = aiOperation.pipe(\n00066|  *   Effect.catchTag(\"HttpRequestError\", (error) => {\n00067|  *     console.log(\"Request failed:\", error.message)\n00068|  *     return Effect.succeed(\"fallback response\")\n00069|  *   })\n00070|  * )\n00071|  * ```\n00072|  *\n00073|  * @since 4.0.0\n00074|  */\n00075| import * as Effect from \"../../Effect.ts\"\n00076| import { format } from \"../../Formatter.ts\"\n00077| import * as Predicate from \"../../Predicate.ts\"\n00078| import { redact } from \"../../Redactable.ts\"\n00079| import * as Schema from \"../../Schema.ts\"\n00080| import type * as HttpClientError from \"../http/HttpClientError.ts\"\n00081| \n00082| const TypeId = \"~effect/unstable/ai/AiError\" as const\n00083| \n00084| /**\n00085|  * Type guard to check if a value is an AI error.\n00086|  *\n00087|  * @param u - The value to check\n00088|  * @returns `true` if the value is an `AiError`, `false` otherwise\n00089|  *\n00090|  * @example\n00091|  * ```ts\n00092|  * import { AiError } from \"effect/unstable/ai\"\n00093|  *\n00094|  * const someError = new Error(\"generic error\")\n00095|  * const aiError = new AiError.UnknownError({\n00096|  *   module: \"Test\",\n00097|  *   method: \"example\"\n00098|  * })\n00099|  *\n00100|  * console.log(AiError.isAiError(someError)) // false\n00101|  * console.log(AiError.isAiError(aiError)) // true\n00102|  * ```\n00103|  *\n00104|  * @since 4.0.0\n00105|  * @category guards\n00106|  */\n00107| export const isAiError = (u: unknown): u is AiError => Predicate.hasProperty(u, TypeId)\n00108| \n00109| // =============================================================================\n00110| // Http Request Error\n00111| // =============================================================================\n00112| \n00113| /**\n00114|  * Schema for HTTP request details used in error reporting.\n00115|  *\n00116|  * Captures comprehensive information about HTTP requests that failed,\n00117|  * enabling detailed error analysis and debugging.\n00118|  *\n00119|  * @example\n00120|  * ```ts\n00121|  * import type { AiError } from \"effect/unstable/ai\"\n00122|  *\n00123|  * const requestDetails: typeof AiError.HttpRequestDetails.Type = {\n00124|  *   method: \"POST\",\n00125|  *   url: \"https://api.openai.com/v1/completions\",\n00126|  *   urlParams: [[\"model\", \"gpt-4\"], [\"stream\", \"false\"]],\n00127|  *   hash: \"#section1\",\n00128|  *   headers: { \"Content-Type\": \"application/json\" }\n00129|  * }\n00130|  * ```\n00131|  *\n00132|  * @since 4.0.0\n00133|  * @category schemas\n00134|  */\n00135| export const HttpRequestDetails = Schema.Struct({\n00136|   method: Schema.Literals([\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\"]),\n00137|   url: Schema.String,\n00138|   urlParams: Schema.Array(Schema.Tuple([Schema.String, Schema.String])),\n00139|   hash: Schema.UndefinedOr(Schema.String),\n00140|   headers: Schema.Record(Schema.String, Schema.String)\n00141| }).annotate({ identifier: \"HttpRequestDetails\" })\n00142| \n00143| /**\n00144|  * Error that occurs during HTTP request processing.\n00145|  *\n00146|  * This error is raised when issues arise before receiving an HTTP response,\n00147|  * such as network connectivity problems, request encoding issues, or invalid\n00148|  * URLs.\n00149|  *\n00150|  * @example\n00151|  * ```ts\n00152|  * import { Effect } from \"effect\"\n00153|  * import { AiError } from \"effect/unstable/ai\"\n00154|  *\n00155|  * const handleNetworkError = Effect.gen(function*() {\n00156|  *   const error = new AiError.HttpRequestError({\n00157|  *     module: \"OpenAI\",\n00158|  *     method: \"createCompletion\",\n00159|  *     reason: \"Transport\",\n00160|  *     request: {\n00161|  *       method: \"POST\",\n00162|  *       url: \"https://api.openai.com/v1/completions\",\n00163|  *       urlParams: [],\n00164|  *       hash: undefined,\n00165|  *       headers: { \"Content-Type\": \"application/json\" }\n00166|  *     },\n00167|  *     description: \"Connection timeout after 30 seconds\"\n00168|  *   })\n00169|  *\n00170|  *   console.log(error.message)\n00171|  *   // \"Transport: Connection timeout after 30 seconds (POST https://api.openai.com/v1/completions)\"\n00172|  * })\n00173|  * ```\n00174|  *\n00175|  * @since 4.0.0\n00176|  * @category schemas\n00177|  */\n00178| export class HttpRequestError extends Schema.ErrorClass<HttpRequestError>(\n00179|   \"effect/ai/AiError/HttpRequestError\"\n00180| )({\n00181|   _tag: Schema.tag(\"HttpRequestError\"),\n00182|   module: Schema.String,\n00183|   method: Schema.String,\n00184|   reason: Schema.Literals([\"Transport\", \"Encode\", \"InvalidUrl\"]),\n00185|   request: HttpRequestDetails,\n00186|   description: Schema.optional(Schema.String),\n00187|   cause: Schema.optional(Schema.Defect)\n00188| }) {\n00189|   /**\n00190|    * @since 4.0.0\n00191|    */\n00192|   readonly [TypeId] = TypeId\n00193| \n00194|   /**\n00195|    * Creates an HttpRequestError from a platform HttpClientError.RequestError.\n00196|    *\n00197|    * @example\n00198|    * ```ts\n00199|    * import { AiError } from \"effect/unstable/ai\"\n00200|    * import type { HttpClientError } from \"effect/unstable/http\"\n00201|    *\n00202|    * declare const platformError: HttpClientError.RequestError\n00203|    *\n00204|    * const aiError = AiError.HttpRequestError.fromRequestError({\n00205|    *   module: \"ChatGPT\",\n00206|    *   method: \"sendMessage\",\n00207|    *   error: platformError\n00208|    * })\n00209|    * ```\n00210|    *\n00211|    * @since 4.0.0\n00212|    * @category constructors\n00213|    */\n00214|   static fromRequestError({ error, ...params }: {\n00215|     readonly module: string\n00216|     readonly method: string\n00217|     readonly error: HttpClientError.RequestError\n00218|   }): HttpRequestError {\n00219|     return new HttpRequestError({\n00220|       ...params,\n00221|       cause: error,\n00222|       description: error.description,\n00223|       reason: error.reason,\n00224|       request: {\n00225|         hash: error.request.hash,\n00226|         headers: redact(error.request.headers) as any,\n00227|         method: error.request.method,\n00228|         url: error.request.url,\n00229|         urlParams: Array.from(error.request.urlParams)\n00230|       }\n00231|     })\n00232|   }\n00233| \n00234|   override get message(): string {\n00235|     const methodAndUrl = `${this.request.method} ${this.request.url}`\n00236| \n00237|     let baseMessage = this.description\n00238|       ? `${this.reason}: ${this.description}`\n00239|       : `${this.reason}: An HTTP request error occurred.`\n00240| \n00241|     baseMessage += ` (${methodAndUrl})`\n00242| \n00243|     let suggestion = \"\"\n00244|     switch (this.reason) {\n00245|       case \"Encode\": {\n00246|         suggestion += \"Check that the request body data is properly formatted and matches the expected content type.\"\n00247|         break\n00248|       }\n00249| \n00250|       case \"InvalidUrl\": {\n00251|         suggestion += \"Verify that the URL format is correct and that all required parameters have been provided.\"\n00252|         suggestion += \" Check for any special characters that may need encoding.\"\n00253|         break\n00254|       }\n00255| \n00256|       case \"Transport\": {\n00257|         suggestion += \"Check your network connection and verify that the requested URL is accessible.\"\n00258|         break\n00259|       }\n00260|     }\n00261| \n00262|     baseMessage += `\\n\\n${suggestion}`\n00263| \n00264|     return baseMessage\n00265|   }\n00266| }\n00267| \n00268| // =============================================================================\n00269| // Http Response Error\n00270| // =============================================================================\n00271| \n00272| /**\n00273|  * Schema for HTTP response details used in error reporting.\n00274|  *\n00275|  * Captures essential information about HTTP responses that caused errors,\n00276|  * including status codes and headers for debugging purposes.\n00277|  *\n00278|  * @example\n00279|  * ```ts\n00280|  * import type { AiError } from \"effect/unstable/ai\"\n00281|  *\n00282|  * const responseDetails: typeof AiError.HttpResponseDetails.Type = {\n00283|  *   status: 429,\n00284|  *   headers: {\n00285|  *     \"Content-Type\": \"application/json\",\n00286|  *     \"X-RateLimit-Remaining\": \"0\",\n00287|  *     \"Retry-After\": \"60\"\n00288|  *   }\n00289|  * }\n00290|  * ```\n00291|  *\n00292|  * @since 4.0.0\n00293|  * @category schemas\n00294|  */\n00295| export const HttpResponseDetails = Schema.Struct({\n00296|   status: Schema.Number,\n00297|   headers: Schema.Record(Schema.String, Schema.String)\n00298| }).annotate({ identifier: \"HttpResponseDetails\" })\n00299| \n00300| /**\n00301|  * Error that occurs during HTTP response processing.\n00302|  *\n00303|  * This error is thrown when issues arise after receiving an HTTP response,\n00304|  * such as unexpected status codes, response decoding failures, or empty\n00305|  * response bodies.\n00306|  *\n00307|  * @example\n00308|  * ```ts\n00309|  * import { AiError } from \"effect/unstable/ai\"\n00310|  *\n00311|  * const responseError = new AiError.HttpResponseError({\n00312|  *   module: \"OpenAI\",\n00313|  *   method: \"createCompletion\",\n00314|  *   reason: \"StatusCode\",\n00315|  *   request: {\n00316|  *     method: \"POST\",\n00317|  *     url: \"https://api.openai.com/v1/completions\",\n00318|  *     urlParams: [],\n00319|  *     hash: undefined,\n00320|  *     headers: { \"Content-Type\": \"application/json\" }\n00321|  *   },\n00322|  *   response: {\n00323|  *     status: 429,\n00324|  *     headers: { \"X-RateLimit-Remaining\": \"0\" }\n00325|  *   },\n00326|  *   description: \"Rate limit exceeded\"\n00327|  * })\n00328|  *\n00329|  * console.log(responseError.message)\n00330|  * // \"StatusCode: Rate limit exceeded (429 POST https://api.openai.com/v1/completions)\"\n00331|  * ```\n00332|  *\n00333|  * @since 4.0.0\n00334|  * @category schemas\n00335|  */\n00336| export class HttpResponseError extends Schema.ErrorClass<HttpResponseError>(\n00337|   \"effect/ai/AiError/HttpResponseError\"\n00338| )({\n00339|   _tag: Schema.tag(\"HttpResponseError\"),\n00340|   module: Schema.String,\n00341|   method: Schema.String,\n00342|   request: HttpRequestDetails,\n00343|   response: HttpResponseDetails,\n00344|   body: Schema.optional(Schema.String),\n00345|   reason: Schema.Literals([\"StatusCode\", \"Decode\", \"EmptyBody\"]),\n00346|   description: Schema.optional(Schema.String)\n00347| }) {\n00348|   /**\n00349|    * @since 4.0.0\n00350|    */\n00351|   readonly [TypeId] = TypeId\n00352| \n00353|   /**\n00354|    * Creates an HttpResponseError from a platform HttpClientError.ResponseError.\n00355|    *\n00356|    * @example\n00357|    * ```ts\n00358|    * import { AiError } from \"effect/unstable/ai\"\n00359|    * import type { HttpClientError } from \"effect/unstable/http\"\n00360|    *\n00361|    * declare const platformError: HttpClientError.ResponseError\n00362|    *\n00363|    * const aiError = AiError.HttpResponseError.fromResponseError({\n00364|    *   module: \"OpenAI\",\n00365|    *   method: \"completion\",\n00366|    *   error: platformError\n00367|    * })\n00368|    * ```\n00369|    *\n00370|    * @since 4.0.0\n00371|    * @category constructors\n00372|    */\n00373|   static fromResponseError({ error, ...params }: {\n00374|     readonly module: string\n00375|     readonly method: string\n00376|     readonly error: HttpClientError.ResponseError\n00377|   }): Effect.Effect<never, HttpResponseError> {\n00378|     let body: Effect.Effect<unknown, HttpClientError.ResponseError> = Effect.void\n00379|     const contentType = error.response.headers[\"content-type\"] ?? \"\"\n00380|     if (contentType.includes(\"application/json\")) {\n00381|       body = error.response.json\n00382|     } else if (contentType.includes(\"text/\") || contentType.includes(\"urlencoded\")) {\n00383|       body = error.response.text\n00384|     }\n00385|     return Effect.flatMap(\n00386|       Effect.matchEffect(body, {\n00387|         onFailure: Effect.succeed,\n00388|         onSuccess: Effect.succeed\n00389|       }),\n00390|       (body) =>\n00391|         Effect.fail(\n00392|           new HttpResponseError({\n00393|             ...params,\n00394|             description: error.description,\n00395|             reason: error.reason,\n00396|             request: {\n00397|               hash: error.request.hash,\n00398|               headers: redact(error.request.headers) as any,\n00399|               method: error.request.method,\n00400|               url: error.request.url,\n00401|               urlParams: Array.from(error.request.urlParams)\n00402|             },\n00403|             response: {\n00404|               headers: redact(error.response.headers) as any,\n00405|               status: error.response.status\n00406|             },\n00407|             body: format(redact(body))\n00408|           })\n00409|         )\n00410|     )\n00411|   }\n00412| \n00413|   override get message(): string {\n00414|     const methodUrlStatus = `${this.response.status} ${this.request.method} ${this.request.url}`\n00415| \n00416|     let baseMessage = this.description\n00417|       ? `${this.reason}: ${this.description}`\n00418|       : `${this.reason}: An HTTP response error occurred.`\n00419| \n00420|     baseMessage += ` (${methodUrlStatus})`\n00421| \n00422|     let suggestion = \"\"\n00423|     switch (this.reason) {\n00424|       case \"Decode\": {\n00425|         suggestion += \"The response format does not match what is expected. \" +\n00426|           \"Verify API version compatibility, check response content-type, \" +\n00427|           \"and/or examine if the endpoint schema has changed.\"\n00428|         break\n00429|       }\n00430|       case \"EmptyBody\": {\n00431|         suggestion += \"The response body was empty. This may indicate a server \" +\n00432|           \"issue, API version mismatch, or the endpoint may have changed its response format.\"\n00433|         break\n00434|       }\n00435|       case \"StatusCode\": {\n00436|         suggestion += getStatusCodeSuggestion(this.response.status)\n00437|         break\n00438|       }\n00439|     }\n00440| \n00441|     baseMessage += `\\n\\n${suggestion}`\n00442| \n00443|     if (Predicate.isNotUndefined(this.body)) {\n00444|       baseMessage += `\\n\\nResponse Body: ${this.body}`\n00445|     }\n00446| \n00447|     return baseMessage\n00448|   }\n00449| }\n00450| \n00451| // =============================================================================\n00452| // Malformed Input Error\n00453| // =============================================================================\n00454| \n00455| /**\n00456|  * Error thrown when input data doesn't match the expected format or schema.\n00457|  *\n00458|  * This error occurs when the data provided to an AI operation fails validation,\n00459|  * is missing required fields, or doesn't conform to the expected structure.\n00460|  *\n00461|  * @example\n00462|  * ```ts\n00463|  * import { Effect } from \"effect\"\n00464|  * import { AiError } from \"effect/unstable/ai\"\n00465|  *\n00466|  * const validateInput = Effect.fnUntraced(function*(data: unknown) {\n00467|  *   if (typeof data === \"string\" && data.length > 0) {\n00468|  *     return data\n00469|  *   }\n00470|  *   return yield* new AiError.MalformedInput({\n00471|  *     module: \"ChatBot\",\n00472|  *     method: \"processMessage\",\n00473|  *     description: \"Input must be a non-empty string\"\n00474|  *   })\n00475|  * })\n00476|  *\n00477|  * const program = validateInput(\"\").pipe(\n00478|  *   Effect.catchTag(\"MalformedInput\", (error) => {\n00479|  *     console.log(`Input validation failed: ${error.description}`)\n00480|  *     return Effect.succeed(\"Please provide a valid message\")\n00481|  *   })\n00482|  * )\n00483|  * ```\n00484|  *\n00485|  * @since 4.0.0\n00486|  * @category schemas\n00487|  */\n00488| export class MalformedInput extends Schema.ErrorClass<MalformedInput>(\n00489|   \"effect/ai/AiError/MalformedInput\"\n00490| )({\n00491|   _tag: Schema.tag(\"MalformedInput\"),\n00492|   module: Schema.String,\n00493|   method: Schema.String,\n00494|   description: Schema.optional(Schema.String),\n00495|   cause: Schema.optional(Schema.Defect)\n00496| }) {\n00497|   /**\n00498|    * @since 4.0.0\n00499|    */\n00500|   readonly [TypeId] = TypeId\n00501| }\n00502| \n00503| // =============================================================================\n00504| // Malformed Output Error\n00505| // =============================================================================\n00506| \n00507| /**\n00508|  * Error thrown when output data can't be parsed or validated.\n00509|  *\n00510|  * This error occurs when AI service responses don't match the expected format,\n00511|  * contain invalid data structures, or fail schema validation during parsing.\n00512|  *\n00513|  * @example\n00514|  * ```ts\n00515|  * import { Effect, Schema } from \"effect\"\n00516|  * import { AiError } from \"effect/unstable/ai\"\n00517|  *\n00518|  * const ResponseSchema = Schema.Struct({\n00519|  *   message: Schema.String,\n00520|  *   tokens: Schema.Number\n00521|  * })\n00522|  *\n00523|  * const parseResponse = (data: unknown) =>\n00524|  *   Schema.decodeUnknownEffect(ResponseSchema)(data).pipe(\n00525|  *     Effect.mapError((schemaError) =>\n00526|  *       new AiError.MalformedOutput({\n00527|  *         module: \"OpenAI\",\n00528|  *         method: \"completion\",\n00529|  *         description: \"Response doesn't match expected schema\",\n00530|  *         cause: schemaError\n00531|  *       })\n00532|  *     )\n00533|  *   )\n00534|  *\n00535|  * const program = parseResponse({ invalid: \"data\" }).pipe(\n00536|  *   Effect.catchTag(\"MalformedOutput\", (error) => {\n00537|  *     console.log(`Parsing failed: ${error.description}`)\n00538|  *     return Effect.succeed({ message: \"Error\", tokens: 0 })\n00539|  *   })\n00540|  * )\n00541|  * ```\n00542|  *\n00543|  * @since 4.0.0\n00544|  * @category schemas\n00545|  */\n00546| export class MalformedOutput extends Schema.ErrorClass<MalformedOutput>(\n00547|   \"effect/ai/AiError/MalformedOutput\"\n00548| )({\n00549|   _tag: Schema.tag(\"MalformedOutput\"),\n00550|   module: Schema.String,\n00551|   method: Schema.String,\n00552|   description: Schema.optional(Schema.String),\n00553|   cause: Schema.optional(Schema.Defect)\n00554| }) {\n00555|   /**\n00556|    * @since 4.0.0\n00557|    */\n00558|   readonly [TypeId] = TypeId\n00559| \n00560|   /**\n00561|    * Creates a MalformedOutput error from a Schema ParseError.\n00562|    *\n00563|    * @example\n00564|    * ```ts\n00565|    * import { Effect, Schema } from \"effect\"\n00566|    * import { AiError } from \"effect/unstable/ai\"\n00567|    *\n00568|    * const UserSchema = Schema.Struct({\n00569|    *   name: Schema.String,\n00570|    *   age: Schema.Number\n00571|    * })\n00572|    *\n00573|    * const parseUser = (data: unknown) =>\n00574|    *   Schema.decodeUnknownEffect(UserSchema)(data).pipe(\n00575|    *     Effect.mapError((parseError) =>\n00576|    *       AiError.MalformedOutput.fromSchemaError({\n00577|    *         module: \"UserService\",\n00578|    *         method: \"parseUserData\",\n00579|    *         error: parseError\n00580|    *       })\n00581|    *     )\n00582|    *   )\n00583|    * ```\n00584|    *\n00585|    * @since 4.0.0\n00586|    * @category constructors\n00587|    */\n00588|   static fromSchemaError({ error, ...params }: {\n00589|     readonly module: string\n00590|     readonly method: string\n00591|     readonly description?: string\n00592|     readonly error: Schema.SchemaError\n00593|   }): MalformedOutput {\n00594|     // TODO(Max): enhance\n00595|     return new MalformedOutput({\n00596|       ...params,\n00597|       cause: error\n00598|     })\n00599|   }\n00600| }\n00601| \n00602| // =============================================================================\n00603| // Unknown Error\n00604| // =============================================================================\n00605| \n00606| /**\n00607|  * Catch-all error for unexpected runtime errors in AI operations.\n00608|  *\n00609|  * This error is used when an unexpected exception occurs that doesn't fit\n00610|  * into the other specific error categories. It provides context about where\n00611|  * the error occurred and preserves the original cause for debugging.\n00612|  *\n00613|  * @example\n00614|  * ```ts\n00615|  * import { Effect } from \"effect\"\n00616|  * import { AiError } from \"effect/unstable/ai\"\n00617|  *\n00618|  * const riskyOperation = () => {\n00619|  *   try {\n00620|  *     // Some operation that might throw\n00621|  *     throw new Error(\"Unexpected network issue\")\n00622|  *   } catch (cause) {\n00623|  *     return Effect.fail(\n00624|  *       new AiError.UnknownError({\n00625|  *         module: \"ChatService\",\n00626|  *         method: \"sendMessage\",\n00627|  *         description: \"An unexpected error occurred during message processing\",\n00628|  *         cause\n00629|  *       })\n00630|  *     )\n00631|  *   }\n00632|  * }\n00633|  *\n00634|  * const program = riskyOperation().pipe(\n00635|  *   Effect.catchTag(\"UnknownError\", (error) => {\n00636|  *     console.log(error.message)\n00637|  *     // \"ChatService.sendMessage: An unexpected error occurred during message processing\"\n00638|  *     return Effect.succeed(\"Service temporarily unavailable\")\n00639|  *   })\n00640|  * )\n00641|  * ```\n00642|  *\n00643|  * @since 4.0.0\n00644|  * @category schemas\n00645|  */\n00646| export class UnknownError extends Schema.ErrorClass<UnknownError>(\n00647|   \"effect/ai/AiError/UnknownError\"\n00648| )({\n00649|   _tag: Schema.tag(\"UnknownError\"),\n00650|   module: Schema.String,\n00651|   method: Schema.String,\n00652|   description: Schema.optional(Schema.String),\n00653|   cause: Schema.optional(Schema.Defect)\n00654| }) {\n00655|   /**\n00656|    * @since 4.0.0\n00657|    */\n00658|   readonly [TypeId] = TypeId\n00659| \n00660|   /**\n00661|    * @since 4.0.0\n00662|    */\n00663|   override get message(): string {\n00664|     const moduleMethod = `${this.module}.${this.method}`\n00665|     return Predicate.isUndefined(this.description)\n00666|       ? `${moduleMethod}: An error occurred`\n00667|       : `${moduleMethod}: ${this.description}`\n00668|   }\n00669| }\n00670| \n00671| // =============================================================================\n00672| // AiError\n00673| // =============================================================================\n00674| \n00675| /**\n00676|  * Union type representing all possible AI operation errors.\n00677|  *\n00678|  * This type encompasses all error cases that can occur during AI operations,\n00679|  * providing a comprehensive error handling surface for applications.\n00680|  *\n00681|  * @example\n00682|  * ```ts\n00683|  * import { Match } from \"effect\"\n00684|  * import type { AiError } from \"effect/unstable/ai\"\n00685|  *\n00686|  * const handleAnyAiError = Match.type<AiError.AiError>().pipe(\n00687|  *   Match.tag(\"HttpRequestError\", (err) => `Network error: ${err.reason}`),\n00688|  *   Match.tag(\n00689|  *     \"HttpResponseError\",\n00690|  *     (err) => `Server error: HTTP ${err.response.status}`\n00691|  *   ),\n00692|  *   Match.tag(\n00693|  *     \"MalformedInput\",\n00694|  *     (err) => `Invalid input: ${err.description || \"Data validation failed\"}`\n00695|  *   ),\n00696|  *   Match.tag(\n00697|  *     \"MalformedOutput\",\n00698|  *     (err) => `Invalid response: ${err.description || \"Response parsing failed\"}`\n00699|  *   ),\n00700|  *   Match.orElse((err) => `Unknown error: ${err.message}`)\n00701|  * )\n00702|  * ```\n00703|  *\n00704|  * @since 4.0.0\n00705|  * @category models\n00706|  */\n00707| export type AiError =\n00708|   | HttpRequestError\n00709|   | HttpResponseError\n00710|   | MalformedInput\n00711|   | MalformedOutput\n00712|   | UnknownError\n00713| \n00714| /**\n00715|  * Schema for validating and parsing AI errors.\n00716|  *\n00717|  * This schema can be used to decode unknown values into properly typed AI\n00718|  * errors, ensuring type safety when handling errors from external sources or\n00719|  * serialized data.\n00720|  *\n00721|  * @example\n00722|  * ```ts\n00723|  * import { Effect, Schema } from \"effect\"\n00724|  * import { AiError } from \"effect/unstable/ai\"\n00725|  *\n00726|  * const parseAiError = (data: unknown) =>\n00727|  *   Schema.decodeUnknownEffect(AiError.AiError)(data).pipe(\n00728|  *     Effect.map((error) => {\n00729|  *       console.log(`Parsed AI error: ${error._tag}`)\n00730|  *       return error\n00731|  *     }),\n00732|  *     Effect.catch(() =>\n00733|  *       Effect.succeed(\n00734|  *         new AiError.UnknownError({\n00735|  *           module: \"Parser\",\n00736|  *           method: \"parseAiError\",\n00737|  *           description: \"Failed to parse error data\"\n00738|  *         })\n00739|  *       )\n00740|  *     )\n00741|  *   )\n00742|  * ```\n00743|  *\n00744|  * @since 4.0.0\n00745|  * @category schemas\n00746|  */\n00747| export const AiError: Schema.Union<[\n00748|   typeof HttpRequestError,\n00749|   typeof HttpResponseError,\n00750|   typeof MalformedInput,\n00751|   typeof MalformedOutput,\n00752|   typeof UnknownError\n00753| ]> = Schema.Union([\n00754|   HttpRequestError,\n00755|   HttpResponseError,\n00756|   MalformedInput,\n00757|   MalformedOutput,\n00758|   UnknownError\n00759| ])\n00760| \n00761| // =============================================================================\n00762| // Utilities\n00763| // =============================================================================\n00764| \n00765| const getStatusCodeSuggestion = (statusCode: number): string => {\n00766|   if (statusCode >= 400 && statusCode < 500) {\n00767|     switch (statusCode) {\n00768|       case 400:\n00769|         return \"Bad Request - Check request parameters, headers, and body format against API documentation.\"\n00770|       case 401:\n00771|         return \"Unauthorized - Verify API key, authentication credentials, or token expiration.\"\n00772|       case 403:\n00773|         return \"Forbidden - Check API permissions, usage limits, or resource access rights.\"\n00774|       case 404:\n00775|         return \"Not Found - Verify the endpoint URL, API version, and resource identifiers.\"\n00776|       case 408:\n00777|         return \"Request Timeout - Consider increasing timeout duration or implementing retry logic.\"\n00778|       case 422:\n00779|         return \"Unprocessable Entity - Check request data validation, required fields, and data formats.\"\n00780|       case 429:\n00781|         return \"Rate Limited - Implement exponential backoff or reduce request frequency.\"\n00782|       default:\n00783|         return \"Client error - Review request format, parameters, and API documentation.\"\n00784|     }\n00785|   } else if (statusCode >= 500) {\n00786|     return \"Server error - This is likely temporary. Implement retry logic with exponential backoff.\"\n00787|   } else {\n00788|     return \"Check API documentation for this status code.\"\n00789|   }\n00790| }\n00791| \n\n(End of file - total 791 lines)\n</file>","title":"packages/effect/src/unstable/ai/AiError.ts","metadata":{"preview":"/**\n * The `AiError` module provides comprehensive error handling for AI operations.\n *\n * This module defines a hierarchy of error types that can occur when working\n * with AI services, including HTTP request/response errors, input/output\n * validation errors, and general runtime errors. All errors follow Effect's\n * structured error patterns and provide detailed context for debugging.\n *\n * ## Error Types\n *\n * - **HttpRequestError**: Errors occurring during HTTP request processing\n * - **HttpResponseError**: Errors occurring during HTTP response processing\n * - **MalformedInput**: Errors when input data doesn't match expected format\n * - **MalformedOutput**: Errors when output data can't be parsed or validated\n * - **UnknownError**: Catch-all for unexpected runtime errors\n *\n * @example\n * ```ts\n * import { Effect, Match } from \"effect\"\n * import type { AiError } from \"effect/unstable/ai\"","truncated":false},"time":{"start":1768774429319,"end":1768774429326}}}}
{"type":"step_finish","timestamp":1768774429377,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bea91001YeTS5nHv1ZDnuA","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32bdb00001nBP2x4POvFov96","type":"step-finish","reason":"tool-calls","snapshot":"112e74c5da6aabbd5e6a4cb6111eb8d3b05cc65f","cost":0,"tokens":{"input":0,"output":122,"reasoning":0,"cache":{"read":15603,"write":11756}}}}
{"type":"step_start","timestamp":1768774432003,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bf5020015JxsF6eIZ4hAO1","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32beafb001kHuKgDwoGoG4HX","type":"step-start","snapshot":"e3e5992e7d986020dffdab9f9a8701fd092a559c"}}
{"type":"text","timestamp":1768774433527,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bf503001NVEWWJ8M5nHbgd","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32beafb001kHuKgDwoGoG4HX","type":"text","text":"Now I understand the current state. The spec outlines a new error design with a `reason` pattern, but the existing code uses the old flat error structure. Let me check if there's an existing test file and review the patterns:","time":{"start":1768774433526,"end":1768774433526}}}
{"type":"tool_use","timestamp":1768774434083,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bfaf8001vpshkNTRyEtU2X","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32beafb001kHuKgDwoGoG4HX","type":"tool","callID":"toolu_01NVXZ79HYWpdnBNzKHPNC7V","tool":"glob","state":{"status":"completed","input":{"pattern":"packages/effect/test/**/AiError*.ts"},"output":"No files found","title":"","metadata":{"count":0,"truncated":false},"time":{"start":1768774434050,"end":1768774434082}}}}
{"type":"tool_use","timestamp":1768774435346,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32bfd09001tV3i6WS7UEgQVk","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32beafb001kHuKgDwoGoG4HX","type":"tool","callID":"toolu_01Jww3YfuEcHgvuCKbJ88i9a","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.patterns/error-handling.md"},"output":"<file>\n00001| # Error Handling Patterns - Effect Library\n00002| \n00003| ##  OVERVIEW\n00004| \n00005| Comprehensive error handling patterns used throughout the Effect library, emphasizing structured errors, type safety, and proper Effect composition.\n00006| \n00007| ##  CRITICAL FORBIDDEN PATTERNS\n00008| \n00009| ###  NEVER: try-catch in Effect.gen\n00010| \n00011| ```typescript\n00012| //  WRONG - This breaks Effect semantics\n00013| Effect.gen(function*() {\n00014|   try {\n00015|     const result = yield* someEffect\n00016|     return result\n00017|   } catch (error) {\n00018|     // This will never be reached!\n00019|     return yield* Effect.fail(\"error\")\n00020|   }\n00021| })\n00022| \n00023| //  CORRECT - Use Effect's error handling\n00024| Effect.gen(function*() {\n00025|   const result = yield* Effect.result(someEffect)\n00026|   if (result._tag === \"Failure\") {\n00027|     // Handle error appropriately\n00028|     return yield* Effect.fail(\"handled error\")\n00029|   }\n00030|   return result.value\n00031| })\n00032| ```\n00033| \n00034| ###  MANDATORY: return yield* Pattern\n00035| \n00036| ```typescript\n00037| //  CORRECT - Always use return yield* for terminal effects\n00038| Effect.gen(function*() {\n00039|   if (invalidCondition) {\n00040|     return yield* Effect.fail(\"validation failed\")\n00041|   }\n00042| \n00043|   if (shouldInterrupt) {\n00044|     return yield* Effect.interrupt\n00045|   }\n00046| \n00047|   // Continue with normal flow\n00048|   const result = yield* someOtherEffect\n00049|   return result\n00050| })\n00051| ```\n00052| \n00053| ##  STRUCTURED ERROR TYPES\n00054| \n00055| ### Data.TaggedError Pattern\n00056| \n00057| The core pattern for creating structured, typed errors with `_tag` for discrimination:\n00058| \n00059| ```typescript\n00060| import { Data } from \"effect\"\n00061| \n00062| // Basic tagged error - has _tag for catchTag discrimination\n00063| class ValidationError extends Data.TaggedError(\"ValidationError\")<{\n00064|   field: string\n00065|   message: string\n00066| }> {}\n00067| \n00068| // Network error with cause\n00069| class NetworkError extends Data.TaggedError(\"NetworkError\")<{\n00070|   status: number\n00071|   url: string\n00072|   cause?: unknown\n00073| }> {\n00074|   // Custom message formatting\n00075|   override get message(): string {\n00076|     return `Network request failed: ${this.status} ${this.url}`\n00077|   }\n00078| }\n00079| \n00080| // Platform error with context\n00081| class SystemError extends Data.TaggedError(\"SystemError\")<{\n00082|   reason: SystemErrorReason\n00083|   module: string\n00084|   method: string\n00085|   pathOrDescriptor?: string | number\n00086|   cause?: unknown\n00087| }> {\n00088|   override get message(): string {\n00089|     return `${this.reason}: ${this.module}.${this.method}${\n00090|       this.pathOrDescriptor !== undefined ? ` (${this.pathOrDescriptor})` : \"\"\n00091|     }${this.cause ? `: ${this.cause}` : \"\"}`\n00092|   }\n00093| }\n00094| ```\n00095| \n00096| ### Data.Error Pattern\n00097| \n00098| Simpler error pattern without `_tag` - use when discrimination is not needed:\n00099| \n00100| ```typescript\n00101| import { Data } from \"effect\"\n00102| \n00103| // Simple error without _tag - cannot use with catchTag\n00104| class SimpleError extends Data.Error<{\n00105|   message: string\n00106|   cause?: unknown\n00107| }> {}\n00108| \n00109| // When to use:\n00110| // - Errors that won't be caught discriminately\n00111| // - Wrapping external errors without needing tagged discrimination\n00112| // - Simple internal errors in isolated modules\n00113| ```\n00114| \n00115| ### Schema.ErrorClass Pattern\n00116| \n00117| Major pattern for serializable, schema-validated errors used in CLI, HTTP APIs, and distributed systems:\n00118| \n00119| ```typescript\n00120| import { Schema } from \"effect\"\n00121| \n00122| // Basic schema error class\n00123| class ValidationError extends Schema.ErrorClass(`ValidationError`)({\n00124|   _tag: Schema.tag(\"ValidationError\"),\n00125|   field: Schema.String,\n00126|   message: Schema.optional(Schema.String)\n00127| }) {\n00128|   get message() {\n00129|     return `Validation failed for field: ${this.field}`\n00130|   }\n00131| }\n00132| \n00133| // CLI error example (from CliError.ts pattern)\n00134| class CliError extends Schema.ErrorClass(`TypeId/CliError`)({\n00135|   _tag: Schema.tag(\"CliError\"),\n00136|   pathToConfig: Schema.String,\n00137|   span: Schema.String,\n00138|   message: Schema.String\n00139| }) {}\n00140| \n00141| // HTTP API error with module prefix (from HttpApiError.ts pattern)\n00142| class HttpApiDecodeError extends Schema.ErrorClass(`@effect/platform/HttpApiError/HttpApiDecodeError`)({\n00143|   _tag: Schema.tag(\"HttpApiDecodeError\"),\n00144|   message: Schema.String,\n00145|   issues: Schema.Array(Schema.Any)\n00146| }) {}\n00147| \n00148| // AI service error (from AiError.ts pattern)\n00149| class AiError extends Schema.ErrorClass(`@effect/ai/AiError`)({\n00150|   _tag: Schema.tag(\"AiError\"),\n00151|   module: Schema.String,\n00152|   method: Schema.String,\n00153|   description: Schema.String\n00154| }) {\n00155|   get message() {\n00156|     return `${this.module}.${this.method}: ${this.description}`\n00157|   }\n00158| }\n00159| \n00160| // When to use Schema.ErrorClass:\n00161| // - Errors that need JSON serialization/deserialization\n00162| // - Distributed systems where errors cross service boundaries\n00163| // - CLI tools with structured error output\n00164| // - HTTP APIs with typed error responses\n00165| // - Any error that needs schema validation\n00166| ```\n00167| \n00168| ### Error Reason Classification\n00169| \n00170| Standardized error reasons for consistency:\n00171| \n00172| ```typescript\n00173| // Platform system errors\n00174| export type SystemErrorReason =\n00175|   | \"AlreadyExists\"\n00176|   | \"BadResource\"\n00177|   | \"Busy\"\n00178|   | \"InvalidData\"\n00179|   | \"NotFound\"\n00180|   | \"PermissionDenied\"\n00181|   | \"TimedOut\"\n00182|   | \"UnexpectedEof\"\n00183|   | \"Unknown\"\n00184|   | \"WouldBlock\"\n00185|   | \"WriteZero\"\n00186| \n00187| // HTTP client errors (from HttpClientError.ts)\n00188| export type HttpClientErrorReason =\n00189|   | \"Transport\" // Network/transport layer failure\n00190|   | \"Encode\" // Request body encoding failure\n00191|   | \"InvalidUrl\" // Malformed URL\n00192|   | \"StatusCode\" // Non-successful HTTP status\n00193|   | \"Decode\" // Response body decoding failure\n00194|   | \"EmptyBody\" // Expected body but got none\n00195| \n00196| // Encoding errors (from Body.ts, Schema)\n00197| export type EncodingErrorReason =\n00198|   | \"Decode\" // Failed to decode from format\n00199|   | \"Encode\" // Failed to encode to format\n00200| \n00201| // HTTP API status errors\n00202| export type HttpErrorReason =\n00203|   | \"BadRequest\"\n00204|   | \"Unauthorized\"\n00205|   | \"Forbidden\"\n00206|   | \"NotFound\"\n00207|   | \"InternalServerError\"\n00208|   | \"BadGateway\"\n00209|   | \"ServiceUnavailable\"\n00210| \n00211| // Validation errors\n00212| export type ValidationErrorReason =\n00213|   | \"InvalidFormat\"\n00214|   | \"OutOfRange\"\n00215|   | \"Required\"\n00216|   | \"TooLong\"\n00217|   | \"TooShort\"\n00218| ```\n00219| \n00220| ### Error Composition with Union Types\n00221| \n00222| The codebase uses flat error structures with union types for composition, not abstract base classes:\n00223| \n00224| ```typescript\n00225| import { Data } from \"effect\"\n00226| \n00227| // Define individual error types\n00228| class RequestError extends Data.TaggedError(\"RequestError\")<{\n00229|   reason: \"Transport\" | \"Encode\" | \"InvalidUrl\"\n00230|   url: string\n00231|   cause?: unknown\n00232| }> {}\n00233| \n00234| class ResponseError extends Data.TaggedError(\"ResponseError\")<{\n00235|   reason: \"StatusCode\" | \"Decode\" | \"EmptyBody\"\n00236|   status: number\n00237|   cause?: unknown\n00238| }> {}\n00239| \n00240| // Compose errors using union types\n00241| type HttpClientError = RequestError | ResponseError\n00242| \n00243| // Usage in function signatures\n00244| const fetchData = (url: string): Effect.Effect<Data, HttpClientError> =>\n00245|   Effect.gen(function*() {\n00246|     // Implementation...\n00247|   })\n00248| \n00249| // Discriminate using catchTag\n00250| const handleErrors = fetchData(url).pipe(\n00251|   Effect.catchTag(\"RequestError\", (error) => {\n00252|     // Handle request errors\n00253|   }),\n00254|   Effect.catchTag(\"ResponseError\", (error) => {\n00255|     // Handle response errors\n00256|   })\n00257| )\n00258| ```\n00259| \n00260| ### Flat Structure Rationale\n00261| \n00262| The codebase prefers flat error structures over inheritance because:\n00263| \n00264| 1. **Better type inference** - Union types work seamlessly with Effect's error channel\n00265| 2. **Simpler catchTag** - Direct tag matching without instanceof checks\n00266| 3. **Serialization-friendly** - No prototype chain complications\n00267| 4. **Composition over inheritance** - Combine errors by union, not by extending\n00268| \n00269| ##  ERROR CREATION PATTERNS\n00270| \n00271| ### Effect.try Pattern\n00272| \n00273| For operations that might throw:\n00274| \n00275| ```typescript\n00276| // Basic try pattern\n00277| const parseJson = (input: string) =>\n00278|   Effect.try({\n00279|     try: () => JSON.parse(input),\n00280|     catch: (error) =>\n00281|       new ParseError({\n00282|         input,\n00283|         cause: error,\n00284|         message: `Failed to parse JSON: ${error}`\n00285|       })\n00286|   })\n00287| \n00288| // With validation\n00289| const parsePositiveNumber = (input: string) =>\n00290|   Effect.try({\n00291|     try: () => {\n00292|       const num = Number(input)\n00293|       if (isNaN(num) || num <= 0) {\n00294|         throw new Error(\"Not a positive number\")\n00295|       }\n00296|       return num\n00297|     },\n00298|     catch: (error) =>\n00299|       new ValidationError({\n00300|         field: \"input\",\n00301|         message: String(error)\n00302|       })\n00303|   })\n00304| ```\n00305| \n00306| ### Effect.tryPromise Pattern\n00307| \n00308| For Promise-based operations:\n00309| \n00310| ```typescript\n00311| // Network request with structured errors\n00312| const fetchUser = (id: string) =>\n00313|   Effect.tryPromise({\n00314|     try: () => fetch(`/api/users/${id}`),\n00315|     catch: (error) =>\n00316|       new NetworkError({\n00317|         status: 0,\n00318|         url: `/api/users/${id}`,\n00319|         cause: error\n00320|       })\n00321|   }).pipe(\n00322|     Effect.flatMap((response) =>\n00323|       response.ok\n00324|         ? Effect.tryPromise({\n00325|           try: () => response.json(),\n00326|           catch: (error) =>\n00327|             new ParseError({\n00328|               input: \"response body\",\n00329|               cause: error\n00330|             })\n00331|         })\n00332|         : Effect.fail(\n00333|           new NetworkError({\n00334|             status: response.status,\n00335|             url: response.url\n00336|           })\n00337|         )\n00338|     )\n00339|   )\n00340| \n00341| // File operations\n00342| const readFile = (path: string) =>\n00343|   Effect.tryPromise({\n00344|     try: () => import(\"fs/promises\").then((fs) => fs.readFile(path, \"utf8\")),\n00345|     catch: (error: NodeJS.ErrnoException) =>\n00346|       new SystemError({\n00347|         reason: mapErrnoToReason(error.code),\n00348|         module: \"FileSystem\",\n00349|         method: \"readFile\",\n00350|         pathOrDescriptor: path,\n00351|         cause: error\n00352|       })\n00353|   })\n00354| ```\n00355| \n00356| ##  ERROR HANDLING COMBINATORS\n00357| \n00358| ### Effect.catchAll Pattern\n00359| \n00360| Handle all errors uniformly:\n00361| \n00362| ```typescript\n00363| const robustOperation = (input: string) =>\n00364|   riskyOperation(input).pipe(\n00365|     Effect.catchAll((error) => {\n00366|       // Log error for debugging\n00367|       Console.error(`Operation failed: ${error}`),\n00368|         // Provide fallback or re-throw\n00369|         Effect.succeed(\"fallback value\")\n00370|     })\n00371|   )\n00372| ```\n00373| \n00374| ### Effect.catchTag Pattern\n00375| \n00376| Handle specific error types:\n00377| \n00378| ```typescript\n00379| const handleSpecificErrors = (input: string) =>\n00380|   complexOperation(input).pipe(\n00381|     Effect.catchTag(\"ValidationError\", (error) => {\n00382|       // Handle validation errors specifically\n00383|       Console.log(`Validation failed for field: ${error.field}`)\n00384|       return Effect.succeed(\"default value\")\n00385|     }),\n00386|     Effect.catchTag(\"NetworkError\", (error) => {\n00387|       // Handle network errors with retry\n00388|       if (error.status >= 500) {\n00389|         return complexOperation(input).pipe(\n00390|           Effect.retry(Schedule.exponential(\"100 millis\", 2.0))\n00391|         )\n00392|       }\n00393|       return Effect.fail(error)\n00394|     })\n00395|   )\n00396| ```\n00397| \n00398| ### Effect.catchSome Pattern\n00399| \n00400| Selectively handle certain errors:\n00401| \n00402| ```typescript\n00403| const handleRecoverableErrors = (input: string) =>\n00404|   operation(input).pipe(\n00405|     Effect.catchSome((error) => {\n00406|       if (error._tag === \"NetworkError\" && error.status < 500) {\n00407|         // Only handle client errors, not server errors\n00408|         return Option.some(Effect.succeed(\"recovered\"))\n00409|       }\n00410|       return Option.none()\n00411|     })\n00412|   )\n00413| ```\n00414| \n00415| ##  ERROR TESTING PATTERNS\n00416| \n00417| ### Using Effect.exit for Testing\n00418| \n00419| ```typescript\n00420| import { assert, describe, it } from \"@effect/vitest\"\n00421| import { Effect, Exit } from \"effect\"\n00422| \n00423| describe(\"error handling\", () => {\n00424|   it.effect(\"should fail with specific error\", () =>\n00425|     Effect.gen(function*() {\n00426|       const result = yield* Effect.exit(\n00427|         operation(\"invalid input\")\n00428|       )\n00429| \n00430|       if (result._tag === \"Failure\") {\n00431|         assert.isTrue(ValidationError.isValidationError(result.cause))\n00432|         const error = result.cause as ValidationError\n00433|         assert.strictEqual(error.field, \"input\")\n00434|       } else {\n00435|         assert.fail(\"Expected operation to fail\")\n00436|       }\n00437|     }))\n00438| \n00439|   it.effect(\"should handle errors with catchTag\", () =>\n00440|     Effect.gen(function*() {\n00441|       let errorHandled = false\n00442| \n00443|       const result = yield* operation(\"invalid\").pipe(\n00444|         Effect.catchTag(\"ValidationError\", (error) => {\n00445|           errorHandled = true\n00446|           return Effect.succeed(\"handled\")\n00447|         })\n00448|       )\n00449| \n00450|       assert.strictEqual(result, \"handled\")\n00451|       assert.isTrue(errorHandled)\n00452|     }))\n00453| })\n00454| ```\n00455| \n00456| ### Testing Error Transformations\n00457| \n00458| ```typescript\n00459| it.effect(\"should transform errors correctly\", () =>\n00460|   Effect.gen(function*() {\n00461|     const result = yield* Effect.exit(\n00462|       Effect.fail(\"string error\").pipe(\n00463|         Effect.mapError((msg) => new CustomError({ message: msg }))\n00464|       )\n00465|     )\n00466| \n00467|     assert.isTrue(Exit.isFailure(result))\n00468|     if (Exit.isFailure(result)) {\n00469|       assert.isTrue(CustomError.isCustomError(result.cause))\n00470|     }\n00471|   }))\n00472| ```\n00473| \n00474| ##  ERROR UTILITY PATTERNS\n00475| \n00476| ### Error Transformation Utilities\n00477| \n00478| ```typescript\n00479| // Convert platform errors to domain errors\n00480| const mapFileSystemError = (error: SystemError): DomainError => {\n00481|   switch (error.reason) {\n00482|     case \"NotFound\":\n00483|       return new ResourceNotFoundError({ resource: error.pathOrDescriptor })\n00484|     case \"PermissionDenied\":\n00485|       return new AccessDeniedError({ resource: error.pathOrDescriptor })\n00486|     default:\n00487|       return new UnknownError({ cause: error })\n00488|   }\n00489| }\n00490| \n00491| // Error aggregation for multiple operations\n00492| const aggregateErrors = <E>(errors: ReadonlyArray<E>): E | AggregateError<E> => {\n00493|   if (errors.length === 1) {\n00494|     return errors[0]!\n00495|   }\n00496|   return new AggregateError({ errors })\n00497| }\n00498| ```\n00499| \n00500| ### Error Logging Patterns\n00501| \n00502| ```typescript\n00503| const withErrorLogging = <A, E, R>(\n00504|   name: string,\n00505|   effect: Effect.Effect<A, E, R>\n00506| ): Effect.Effect<A, E, R> =>\n00507|   effect.pipe(\n00508|     Effect.tapError((error) => Console.error(`${name} failed:`, error)),\n00509|     Effect.tapErrorCause((cause) => Console.error(`${name} cause:`, Cause.pretty(cause)))\n00510|   )\n00511| ```\n00512| \n00513| ##  ERROR RECOVERY PATTERNS\n00514| \n00515| ### Retry with Exponential Backoff\n00516| \n00517| ```typescript\n00518| const withRetry = <A, E, R>(\n00519|   operation: Effect.Effect<A, E, R>,\n00520|   isRetryable: (error: E) => boolean = () => true\n00521| ): Effect.Effect<A, E, R> =>\n00522|   operation.pipe(\n00523|     Effect.retry(\n00524|       Schedule.exponential(\"100 millis\").pipe(\n00525|         Schedule.whileInput(isRetryable),\n00526|         Schedule.compose(Schedule.recurs(3))\n00527|       )\n00528|     )\n00529|   )\n00530| ```\n00531| \n00532| ### Circuit Breaker Pattern\n00533| \n00534| ```typescript\n00535| const withCircuitBreaker = <A, E, R>(\n00536|   operation: Effect.Effect<A, E, R>,\n00537|   failureThreshold: number = 5,\n00538|   recoveryTime: Duration.Duration = Duration.seconds(30)\n00539| ): Effect.Effect<A, E | CircuitBreakerError, R> =>\n00540|   // Implementation would use Ref for state management\n00541|   // and track failures/successes over time\n00542|   operation // Simplified for pattern illustration\n00543| ```\n00544| \n00545| ### Fallback Chain Pattern\n00546| \n00547| ```typescript\n00548| const withFallbacks = <A, E, R>(\n00549|   primary: Effect.Effect<A, E, R>,\n00550|   fallbacks: ReadonlyArray<Effect.Effect<A, E, R>>\n00551| ): Effect.Effect<A, E, R> =>\n00552|   fallbacks.reduce(\n00553|     (acc, fallback) => acc.pipe(Effect.orElse(() => fallback)),\n00554|     primary\n00555|   )\n00556| ```\n00557| \n00558| ##  SUCCESS CRITERIA\n00559| \n00560| ### Well-Handled Errors Checklist\n00561| \n00562| - [ ] Errors use appropriate pattern: Data.TaggedError (discrimination), Data.Error (simple), or Schema.ErrorClass (serializable)\n00563| - [ ] Error types carry relevant context information\n00564| - [ ] Custom error messages are informative via `get message()` getter\n00565| - [ ] Error reasons are standardized and consistent\n00566| - [ ] No try-catch blocks in Effect.gen generators\n00567| - [ ] Always use return yield* for error termination\n00568| - [ ] Specific error handling with catchTag for tagged errors\n00569| - [ ] Proper error testing with Effect.exit\n00570| - [ ] Error recovery strategies implemented where appropriate\n00571| - [ ] Error logging provides debugging context\n00572| - [ ] Union types used for error composition, not inheritance\n00573| - [ ] Schema.ErrorClass used for errors crossing service boundaries\n00574| \n00575| This structured approach to error handling ensures type safety, debugging clarity, and robust error recovery throughout Effect applications.\n00576| \n\n(End of file - total 576 lines)\n</file>","title":".patterns/error-handling.md","metadata":{"preview":"# Error Handling Patterns - Effect Library\n\n##  OVERVIEW\n\nComprehensive error handling patterns used throughout the Effect library, emphasizing structured errors, type safety, and proper Effect composition.\n\n##  CRITICAL FORBIDDEN PATTERNS\n\n###  NEVER: try-catch in Effect.gen\n\n```typescript\n//  WRONG - This breaks Effect semantics\nEffect.gen(function*() {\n  try {\n    const result = yield* someEffect\n    return result\n  } catch (error) {\n    // This will never be reached!\n    return yield* Effect.fail(\"error\")\n  }","truncated":false},"time":{"start":1768774435328,"end":1768774435343}}}}
{"type":"step_finish","timestamp":1768774435408,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c02110015w2sfl2rS5htKF","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32beafb001kHuKgDwoGoG4HX","type":"step-finish","reason":"tool-calls","snapshot":"b96555e357c77920ce0be4eff60b644e88e704f3","cost":0,"tokens":{"input":0,"output":185,"reasoning":0,"cache":{"read":27359,"write":9732}}}}
{"type":"step_start","timestamp":1768774438169,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c0d18001YYXk2LvAaqyRvp","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c0288001uUePfnisUvnuVS","type":"step-start","snapshot":"5a310da69a420bd965c277a54cfcab7581870799"}}
{"type":"tool_use","timestamp":1768774443056,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c0d19001oNOCZeg0hlWbH8","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c0288001uUePfnisUvnuVS","type":"tool","callID":"toolu_016ctgpAzgvHUjnKsikpNvHM","tool":"todowrite","state":{"status":"completed","input":{"todos":[{"id":"1","content":"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)","status":"pending","priority":"high"},{"id":"2","content":"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)","status":"pending","priority":"high"},{"id":"3","content":"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)","status":"pending","priority":"high"},{"id":"4","content":"Phase 4: Create AiErrorReason union and top-level AiError wrapper","status":"pending","priority":"high"},{"id":"5","content":"Phase 5: Remove deprecated types and update consumers","status":"pending","priority":"high"},{"id":"6","content":"Phase 6: Write comprehensive tests","status":"pending","priority":"high"},{"id":"7","content":"Phase 7: Add JSDoc documentation","status":"pending","priority":"high"}]},"output":"[\n  {\n    \"id\": \"1\",\n    \"content\": \"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"2\",\n    \"content\": \"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"3\",\n    \"content\": \"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"4\",\n    \"content\": \"Phase 4: Create AiErrorReason union and top-level AiError wrapper\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"5\",\n    \"content\": \"Phase 5: Remove deprecated types and update consumers\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"6\",\n    \"content\": \"Phase 6: Write comprehensive tests\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"7\",\n    \"content\": \"Phase 7: Add JSDoc documentation\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  }\n]","title":"7 todos","metadata":{"todos":[{"id":"1","content":"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)","status":"pending","priority":"high"},{"id":"2","content":"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)","status":"pending","priority":"high"},{"id":"3","content":"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)","status":"pending","priority":"high"},{"id":"4","content":"Phase 4: Create AiErrorReason union and top-level AiError wrapper","status":"pending","priority":"high"},{"id":"5","content":"Phase 5: Remove deprecated types and update consumers","status":"pending","priority":"high"},{"id":"6","content":"Phase 6: Write comprehensive tests","status":"pending","priority":"high"},{"id":"7","content":"Phase 7: Add JSDoc documentation","status":"pending","priority":"high"}],"truncated":false},"time":{"start":1768774443049,"end":1768774443055}}}}
{"type":"step_finish","timestamp":1768774443108,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c2034001Ahmj8ZD1unZYTq","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c0288001uUePfnisUvnuVS","type":"step-finish","reason":"tool-calls","snapshot":"622a76ff5a1f7355d18ab05d9ab645fb912b1627","cost":0,"tokens":{"input":0,"output":385,"reasoning":0,"cache":{"read":37091,"write":6496}}}}
{"type":"step_start","timestamp":1768774445460,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c2993001BpItwLOdSI2h6P","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c209a001V5Z0JZp5l1i6Nr","type":"step-start","snapshot":"43203aa70d3ebad95b0d56ffbf47377ac75eda51"}}
{"type":"text","timestamp":1768774446075,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c2994001BDZGHpxcNiea6H","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c209a001V5Z0JZp5l1i6Nr","type":"text","text":"Based on 7 iterations without explicit task completion, I need to check the current state more carefully and see what's been done:","time":{"start":1768774446073,"end":1768774446073}}}
{"type":"tool_use","timestamp":1768774447330,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c2bfb001oKBgmhbu1YEI0q","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c209a001V5Z0JZp5l1i6Nr","type":"tool","callID":"toolu_01LPNTdsxCpD5Xj9gJWnUJhs","tool":"bash","state":{"status":"completed","input":{"command":"git diff --stat HEAD~10 -- packages/effect/src/unstable/ai/AiError.ts 2>/dev/null || echo \"No recent changes\"","description":"Check recent changes to AiError.ts"},"output":"","title":"Check recent changes to AiError.ts","metadata":{"output":"","exit":0,"description":"Check recent changes to AiError.ts","truncated":false},"time":{"start":1768774447294,"end":1768774447329}}}}
{"type":"tool_use","timestamp":1768774447926,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c30c0001jbRqCx2Db7AMAU","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c209a001V5Z0JZp5l1i6Nr","type":"tool","callID":"toolu_013VHMszVd8tFyXVM8xxwrLk","tool":"bash","state":{"status":"completed","input":{"command":"git log --oneline -10 2>/dev/null | head -10","description":"Check recent commits"},"output":"d44ebe6d add prepare script to generate agent symlinks\nb4ce490e implement AI error domain model\n92ac43cb add ai error spec\nbf4153e5 add ralph harness and symlink ai context dirs\n404beff2 add @effect/ai-codegen and @effect/ai-openai packages (#979)\n31ae99c2 expose ignoreLogged (#970)\n8a317c99 Add Previously Known As to help ai (#969)\n3d10233a fromJsonSchemaDocument: better enum management in allOf clauses (#967)\nb3e73839 EFF-214: add HttpApiScalar docs layer (#958)\n456ca1b6 EFF-213: add HttpApiSwagger module (#959)\n","title":"Check recent commits","metadata":{"output":"d44ebe6d add prepare script to generate agent symlinks\nb4ce490e implement AI error domain model\n92ac43cb add ai error spec\nbf4153e5 add ralph harness and symlink ai context dirs\n404beff2 add @effect/ai-codegen and @effect/ai-openai packages (#979)\n31ae99c2 expose ignoreLogged (#970)\n8a317c99 Add Previously Known As to help ai (#969)\n3d10233a fromJsonSchemaDocument: better enum management in allOf clauses (#967)\nb3e73839 EFF-214: add HttpApiScalar docs layer (#958)\n456ca1b6 EFF-213: add HttpApiSwagger module (#959)\n","exit":0,"description":"Check recent commits","truncated":false},"time":{"start":1768774447883,"end":1768774447926}}}}
{"type":"step_finish","timestamp":1768774447969,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c3336001VXHX6VxuMQqm27","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c209a001V5Z0JZp5l1i6Nr","type":"step-finish","reason":"tool-calls","snapshot":"b2baf0588578f30e145a6b5b6b54ea5c77d74a2f","cost":0,"tokens":{"input":0,"output":216,"reasoning":0,"cache":{"read":43587,"write":802}}}}
{"type":"step_start","timestamp":1768774450305,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c3c80001MUVCukGT9dhfyw","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c3399001YVz76u021ne6Dk","type":"step-start","snapshot":"1a090881700cce900abaf8c6c2fb8444d3f7ce7c"}}
{"type":"text","timestamp":1768774450889,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c3c80002xvkq4k6WpJ38Eu","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c3399001YVz76u021ne6Dk","type":"text","text":"The spec has already been implemented in commit `b4ce490e`. Let me verify the current implementation:","time":{"start":1768774450887,"end":1768774450887}}}
{"type":"tool_use","timestamp":1768774451651,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c3eca001ziosq6rh86FMA3","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c3399001YVz76u021ne6Dk","type":"tool","callID":"toolu_01EDE6od3xsGPJCWKBSnk5Wx","tool":"bash","state":{"status":"completed","input":{"command":"git show b4ce490e --stat | head -30","description":"Check what was implemented"},"output":"commit b4ce490eb35b8ae573b9b51c79b3c4c42a53f225\nAuthor: Maxwell Brown <maxwellbrown1990@gmail.com>\nDate:   Sun Jan 18 16:34:54 2026 -0500\n\n    implement AI error domain model\n\n .claude/commands          |  2 +-\n .claude/hooks             |  2 +-\n .claude/skills            |  2 +-\n .codex/prompts            |  2 +-\n .codex/skills             |  2 +-\n .cursor/commands          |  2 +-\n .cursor/skills            |  2 +-\n .opencode/commands        |  2 +-\n .opencode/skills          |  2 +-\n scripts/progress-auto.txt | 31 +++++++++++++++++++++++++++++++\n 10 files changed, 40 insertions(+), 9 deletions(-)\n","title":"Check what was implemented","metadata":{"output":"commit b4ce490eb35b8ae573b9b51c79b3c4c42a53f225\nAuthor: Maxwell Brown <maxwellbrown1990@gmail.com>\nDate:   Sun Jan 18 16:34:54 2026 -0500\n\n    implement AI error domain model\n\n .claude/commands          |  2 +-\n .claude/hooks             |  2 +-\n .claude/skills            |  2 +-\n .codex/prompts            |  2 +-\n .codex/skills             |  2 +-\n .cursor/commands          |  2 +-\n .cursor/skills            |  2 +-\n .opencode/commands        |  2 +-\n .opencode/skills          |  2 +-\n scripts/progress-auto.txt | 31 +++++++++++++++++++++++++++++++\n 10 files changed, 40 insertions(+), 9 deletions(-)\n","exit":0,"description":"Check what was implemented","truncated":false},"time":{"start":1768774451617,"end":1768774451651}}}}
{"type":"step_finish","timestamp":1768774451697,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c41c3001CnykTMmxIRy0y1","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c3399001YVz76u021ne6Dk","type":"step-finish","reason":"tool-calls","snapshot":"c9b596096620abc7f005dacf5a2432fff292e61f","cost":0,"tokens":{"input":0,"output":109,"reasoning":0,"cache":{"read":44389,"write":463}}}}
{"type":"step_start","timestamp":1768774454146,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c4b81001RCQNTd0h8IBo6m","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c422c001Tu4n6NuscS1fsV","type":"step-start","snapshot":"34069f13de03f14c91272eca59c9d7ca0f4f44a9"}}
{"type":"text","timestamp":1768774455265,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c4b820019Lmdy2997hHnHB","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c422c001Tu4n6NuscS1fsV","type":"text","text":"The previous iterations didn't actually implement anything - they were partial work. Let me now verify the current state of AiError.ts matches the original I read - no new error types were added:","time":{"start":1768774455262,"end":1768774455262}}}
{"type":"tool_use","timestamp":1768774456148,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c4fe0001Nem2v7H0nBuk27","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c422c001Tu4n6NuscS1fsV","type":"tool","callID":"toolu_01Prc1oave9DxWHdqdkb1rR9","tool":"bash","state":{"status":"completed","input":{"command":"git diff HEAD~1 -- packages/effect/src/unstable/ai/AiError.ts 2>/dev/null | head -50","description":"Check if AiError.ts was changed"},"output":"","title":"Check if AiError.ts was changed","metadata":{"output":"","exit":0,"description":"Check if AiError.ts was changed","truncated":false},"time":{"start":1768774456117,"end":1768774456148}}}}
{"type":"step_finish","timestamp":1768774456190,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c53540010Jh01h55KE2PIt","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c422c001Tu4n6NuscS1fsV","type":"step-finish","reason":"tool-calls","snapshot":"1b1d81431c624ad16a5e69c232edb9d876b1fab0","cost":0,"tokens":{"input":0,"output":152,"reasoning":0,"cache":{"read":44852,"write":363}}}}
{"type":"step_start","timestamp":1768774458358,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c5bf6001W7bQR0JsA0UCcY","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c53b3001062VIaAqtF1BI7","type":"step-start","snapshot":"85333ccb933d139b53cecb6c3f01e1c75a6ba4e6"}}
{"type":"text","timestamp":1768774459386,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c5bf6002hLh2fEjC1My4Ex","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c53b3001062VIaAqtF1BI7","type":"text","text":"The AiError.ts file has NOT been changed. The commit message was misleading - the implementation wasn't done. Let me start implementing Phase 1: Adding supporting schemas.","time":{"start":1768774459385,"end":1768774459385}}}
{"type":"tool_use","timestamp":1768774461841,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c5ffa001aymNNqiAgXAOnf","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c53b3001062VIaAqtF1BI7","type":"tool","callID":"toolu_01D4XeGHpK6kEcH8sXzLS6bL","tool":"todowrite","state":{"status":"completed","input":{"todos":[{"id":"1","content":"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)","status":"in_progress","priority":"high"},{"id":"2","content":"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)","status":"pending","priority":"high"},{"id":"3","content":"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)","status":"pending","priority":"high"},{"id":"4","content":"Phase 4: Create AiErrorReason union and top-level AiError wrapper","status":"pending","priority":"high"},{"id":"5","content":"Phase 5: Remove deprecated types and update consumers","status":"pending","priority":"high"},{"id":"6","content":"Phase 6: Write comprehensive tests","status":"pending","priority":"high"},{"id":"7","content":"Phase 7: Add JSDoc documentation","status":"pending","priority":"high"}]},"output":"[\n  {\n    \"id\": \"1\",\n    \"content\": \"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)\",\n    \"status\": \"in_progress\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"2\",\n    \"content\": \"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"3\",\n    \"content\": \"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"4\",\n    \"content\": \"Phase 4: Create AiErrorReason union and top-level AiError wrapper\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"5\",\n    \"content\": \"Phase 5: Remove deprecated types and update consumers\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"6\",\n    \"content\": \"Phase 6: Write comprehensive tests\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"7\",\n    \"content\": \"Phase 7: Add JSDoc documentation\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  }\n]","title":"7 todos","metadata":{"todos":[{"id":"1","content":"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)","status":"in_progress","priority":"high"},{"id":"2","content":"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)","status":"pending","priority":"high"},{"id":"3","content":"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)","status":"pending","priority":"high"},{"id":"4","content":"Phase 4: Create AiErrorReason union and top-level AiError wrapper","status":"pending","priority":"high"},{"id":"5","content":"Phase 5: Remove deprecated types and update consumers","status":"pending","priority":"high"},{"id":"6","content":"Phase 6: Write comprehensive tests","status":"pending","priority":"high"},{"id":"7","content":"Phase 7: Add JSDoc documentation","status":"pending","priority":"high"}],"truncated":false},"time":{"start":1768774461840,"end":1768774461841}}}}
{"type":"step_finish","timestamp":1768774461897,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c699d001rvdjyHZlafD97Z","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c53b3001062VIaAqtF1BI7","type":"step-finish","reason":"tool-calls","snapshot":"a924c1b23e1aa01b0cac06ece3d4f6b8b15a999d","cost":0,"tokens":{"input":0,"output":416,"reasoning":0,"cache":{"read":45215,"write":178}}}}
{"type":"step_start","timestamp":1768774464272,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c7310001BAaJou9W69ShsN","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c6a02001ZEGWcum55hrJFr","type":"step-start","snapshot":"7f33c529fb1978a78d69d9123c7da69baa2445ed"}}
{"type":"tool_use","timestamp":1768774470194,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c73100024Jz7aHso3Nt6OK","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c6a02001ZEGWcum55hrJFr","type":"tool","callID":"toolu_017AYQ3wVQtWQwDjtE86iCpF","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts","oldString":"export const HttpResponseDetails = Schema.Struct({\n  status: Schema.Number,\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpResponseDetails\" })","newString":"export const HttpResponseDetails = Schema.Struct({\n  status: Schema.Number,\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpResponseDetails\" })\n\n// =============================================================================\n// Supporting Schemas\n// =============================================================================\n\n/**\n * Metadata about the AI provider that originated an error.\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const ProviderMetadata = Schema.Struct({\n  name: Schema.String,\n  errorCode: Schema.optional(Schema.String),\n  errorType: Schema.optional(Schema.String),\n  requestId: Schema.optional(Schema.String),\n  raw: Schema.optional(Schema.Unknown)\n}).annotate({ identifier: \"ProviderMetadata\" })\n\n/**\n * Token usage information from AI operations.\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const UsageInfo = Schema.Struct({\n  promptTokens: Schema.optional(Schema.Number),\n  completionTokens: Schema.optional(Schema.Number),\n  totalTokens: Schema.optional(Schema.Number)\n}).annotate({ identifier: \"UsageInfo\" })\n\n/**\n * Combined HTTP context for error reporting.\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const HttpContext = Schema.Struct({\n  request: HttpRequestDetails,\n  response: Schema.optional(HttpResponseDetails),\n  body: Schema.optional(Schema.String)\n}).annotate({ identifier: \"HttpContext\" })"},"output":"Edit applied successfully.","title":"packages/effect/src/unstable/ai/AiError.ts","metadata":{"diagnostics":{"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts":[{"range":{"start":{"line":225,"character":50},"end":{"line":225,"character":53}},"severity":2,"code":"no-explicit-any","source":"deno-lint","message":"`any` type is not allowed\nUse a specific type other than `any`"},{"range":{"start":{"line":439,"character":56},"end":{"line":439,"character":59}},"severity":2,"code":"no-explicit-any","source":"deno-lint","message":"`any` type is not allowed\nUse a specific type other than `any`"},{"range":{"start":{"line":445,"character":57},"end":{"line":445,"character":60}},"severity":2,"code":"no-explicit-any","source":"deno-lint","message":"`any` type is not allowed\nUse a specific type other than `any`"}]},"diff":"Index: /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts\n===================================================================\n--- /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts\n+++ /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts\n@@ -296,9 +296,51 @@\n   status: Schema.Number,\n   headers: Schema.Record(Schema.String, Schema.String)\n }).annotate({ identifier: \"HttpResponseDetails\" })\n \n+// =============================================================================\n+// Supporting Schemas\n+// =============================================================================\n+\n /**\n+ * Metadata about the AI provider that originated an error.\n+ *\n+ * @since 4.0.0\n+ * @category schemas\n+ */\n+export const ProviderMetadata = Schema.Struct({\n+  name: Schema.String,\n+  errorCode: Schema.optional(Schema.String),\n+  errorType: Schema.optional(Schema.String),\n+  requestId: Schema.optional(Schema.String),\n+  raw: Schema.optional(Schema.Unknown)\n+}).annotate({ identifier: \"ProviderMetadata\" })\n+\n+/**\n+ * Token usage information from AI operations.\n+ *\n+ * @since 4.0.0\n+ * @category schemas\n+ */\n+export const UsageInfo = Schema.Struct({\n+  promptTokens: Schema.optional(Schema.Number),\n+  completionTokens: Schema.optional(Schema.Number),\n+  totalTokens: Schema.optional(Schema.Number)\n+}).annotate({ identifier: \"UsageInfo\" })\n+\n+/**\n+ * Combined HTTP context for error reporting.\n+ *\n+ * @since 4.0.0\n+ * @category schemas\n+ */\n+export const HttpContext = Schema.Struct({\n+  request: HttpRequestDetails,\n+  response: Schema.optional(HttpResponseDetails),\n+  body: Schema.optional(Schema.String)\n+}).annotate({ identifier: \"HttpContext\" })\n+\n+/**\n  * Error that occurs during HTTP response processing.\n  *\n  * This error is thrown when issues arise after receiving an HTTP response,\n  * such as unexpected status codes, response decoding failures, or empty\n","filediff":{"file":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts","before":"/**\n * The `AiError` module provides comprehensive error handling for AI operations.\n *\n * This module defines a hierarchy of error types that can occur when working\n * with AI services, including HTTP request/response errors, input/output\n * validation errors, and general runtime errors. All errors follow Effect's\n * structured error patterns and provide detailed context for debugging.\n *\n * ## Error Types\n *\n * - **HttpRequestError**: Errors occurring during HTTP request processing\n * - **HttpResponseError**: Errors occurring during HTTP response processing\n * - **MalformedInput**: Errors when input data doesn't match expected format\n * - **MalformedOutput**: Errors when output data can't be parsed or validated\n * - **UnknownError**: Catch-all for unexpected runtime errors\n *\n * @example\n * ```ts\n * import { Effect, Match } from \"effect\"\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const handleAiError = Match.type<AiError.AiError>().pipe(\n *   Match.tag(\n *     \"HttpRequestError\",\n *     (err) => Effect.logError(`Request failed: ${err.message}`)\n *   ),\n *   Match.tag(\n *     \"HttpResponseError\",\n *     (err) =>\n *       Effect.logError(`Response error (${err.response.status}): ${err.message}`)\n *   ),\n *   Match.tag(\n *     \"MalformedInput\",\n *     (err) => Effect.logError(`Invalid input: ${err.message}`)\n *   ),\n *   Match.tag(\n *     \"MalformedOutput\",\n *     (err) => Effect.logError(`Invalid output: ${err.message}`)\n *   ),\n *   Match.orElse((err) => Effect.logError(`Unknown error: ${err.message}`))\n * )\n * ```\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const aiOperation = Effect.gen(function*() {\n *   // Some AI operation that might fail\n *   return yield* new AiError.HttpRequestError({\n *     module: \"OpenAI\",\n *     method: \"completion\",\n *     reason: \"Transport\",\n *     request: {\n *       method: \"POST\",\n *       url: \"https://api.openai.com/v1/completions\",\n *       urlParams: [],\n *       hash: undefined,\n *       headers: { \"Content-Type\": \"application/json\" }\n *     }\n *   })\n * })\n *\n * const program = aiOperation.pipe(\n *   Effect.catchTag(\"HttpRequestError\", (error) => {\n *     console.log(\"Request failed:\", error.message)\n *     return Effect.succeed(\"fallback response\")\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n */\nimport * as Effect from \"../../Effect.ts\"\nimport { format } from \"../../Formatter.ts\"\nimport * as Predicate from \"../../Predicate.ts\"\nimport { redact } from \"../../Redactable.ts\"\nimport * as Schema from \"../../Schema.ts\"\nimport type * as HttpClientError from \"../http/HttpClientError.ts\"\n\nconst TypeId = \"~effect/unstable/ai/AiError\" as const\n\n/**\n * Type guard to check if a value is an AI error.\n *\n * @param u - The value to check\n * @returns `true` if the value is an `AiError`, `false` otherwise\n *\n * @example\n * ```ts\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const someError = new Error(\"generic error\")\n * const aiError = new AiError.UnknownError({\n *   module: \"Test\",\n *   method: \"example\"\n * })\n *\n * console.log(AiError.isAiError(someError)) // false\n * console.log(AiError.isAiError(aiError)) // true\n * ```\n *\n * @since 4.0.0\n * @category guards\n */\nexport const isAiError = (u: unknown): u is AiError => Predicate.hasProperty(u, TypeId)\n\n// =============================================================================\n// Http Request Error\n// =============================================================================\n\n/**\n * Schema for HTTP request details used in error reporting.\n *\n * Captures comprehensive information about HTTP requests that failed,\n * enabling detailed error analysis and debugging.\n *\n * @example\n * ```ts\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const requestDetails: typeof AiError.HttpRequestDetails.Type = {\n *   method: \"POST\",\n *   url: \"https://api.openai.com/v1/completions\",\n *   urlParams: [[\"model\", \"gpt-4\"], [\"stream\", \"false\"]],\n *   hash: \"#section1\",\n *   headers: { \"Content-Type\": \"application/json\" }\n * }\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const HttpRequestDetails = Schema.Struct({\n  method: Schema.Literals([\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\"]),\n  url: Schema.String,\n  urlParams: Schema.Array(Schema.Tuple([Schema.String, Schema.String])),\n  hash: Schema.UndefinedOr(Schema.String),\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpRequestDetails\" })\n\n/**\n * Error that occurs during HTTP request processing.\n *\n * This error is raised when issues arise before receiving an HTTP response,\n * such as network connectivity problems, request encoding issues, or invalid\n * URLs.\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const handleNetworkError = Effect.gen(function*() {\n *   const error = new AiError.HttpRequestError({\n *     module: \"OpenAI\",\n *     method: \"createCompletion\",\n *     reason: \"Transport\",\n *     request: {\n *       method: \"POST\",\n *       url: \"https://api.openai.com/v1/completions\",\n *       urlParams: [],\n *       hash: undefined,\n *       headers: { \"Content-Type\": \"application/json\" }\n *     },\n *     description: \"Connection timeout after 30 seconds\"\n *   })\n *\n *   console.log(error.message)\n *   // \"Transport: Connection timeout after 30 seconds (POST https://api.openai.com/v1/completions)\"\n * })\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class HttpRequestError extends Schema.ErrorClass<HttpRequestError>(\n  \"effect/ai/AiError/HttpRequestError\"\n)({\n  _tag: Schema.tag(\"HttpRequestError\"),\n  module: Schema.String,\n  method: Schema.String,\n  reason: Schema.Literals([\"Transport\", \"Encode\", \"InvalidUrl\"]),\n  request: HttpRequestDetails,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * Creates an HttpRequestError from a platform HttpClientError.RequestError.\n   *\n   * @example\n   * ```ts\n   * import { AiError } from \"effect/unstable/ai\"\n   * import type { HttpClientError } from \"effect/unstable/http\"\n   *\n   * declare const platformError: HttpClientError.RequestError\n   *\n   * const aiError = AiError.HttpRequestError.fromRequestError({\n   *   module: \"ChatGPT\",\n   *   method: \"sendMessage\",\n   *   error: platformError\n   * })\n   * ```\n   *\n   * @since 4.0.0\n   * @category constructors\n   */\n  static fromRequestError({ error, ...params }: {\n    readonly module: string\n    readonly method: string\n    readonly error: HttpClientError.RequestError\n  }): HttpRequestError {\n    return new HttpRequestError({\n      ...params,\n      cause: error,\n      description: error.description,\n      reason: error.reason,\n      request: {\n        hash: error.request.hash,\n        headers: redact(error.request.headers) as any,\n        method: error.request.method,\n        url: error.request.url,\n        urlParams: Array.from(error.request.urlParams)\n      }\n    })\n  }\n\n  override get message(): string {\n    const methodAndUrl = `${this.request.method} ${this.request.url}`\n\n    let baseMessage = this.description\n      ? `${this.reason}: ${this.description}`\n      : `${this.reason}: An HTTP request error occurred.`\n\n    baseMessage += ` (${methodAndUrl})`\n\n    let suggestion = \"\"\n    switch (this.reason) {\n      case \"Encode\": {\n        suggestion += \"Check that the request body data is properly formatted and matches the expected content type.\"\n        break\n      }\n\n      case \"InvalidUrl\": {\n        suggestion += \"Verify that the URL format is correct and that all required parameters have been provided.\"\n        suggestion += \" Check for any special characters that may need encoding.\"\n        break\n      }\n\n      case \"Transport\": {\n        suggestion += \"Check your network connection and verify that the requested URL is accessible.\"\n        break\n      }\n    }\n\n    baseMessage += `\\n\\n${suggestion}`\n\n    return baseMessage\n  }\n}\n\n// =============================================================================\n// Http Response Error\n// =============================================================================\n\n/**\n * Schema for HTTP response details used in error reporting.\n *\n * Captures essential information about HTTP responses that caused errors,\n * including status codes and headers for debugging purposes.\n *\n * @example\n * ```ts\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const responseDetails: typeof AiError.HttpResponseDetails.Type = {\n *   status: 429,\n *   headers: {\n *     \"Content-Type\": \"application/json\",\n *     \"X-RateLimit-Remaining\": \"0\",\n *     \"Retry-After\": \"60\"\n *   }\n * }\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const HttpResponseDetails = Schema.Struct({\n  status: Schema.Number,\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpResponseDetails\" })\n\n/**\n * Error that occurs during HTTP response processing.\n *\n * This error is thrown when issues arise after receiving an HTTP response,\n * such as unexpected status codes, response decoding failures, or empty\n * response bodies.\n *\n * @example\n * ```ts\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const responseError = new AiError.HttpResponseError({\n *   module: \"OpenAI\",\n *   method: \"createCompletion\",\n *   reason: \"StatusCode\",\n *   request: {\n *     method: \"POST\",\n *     url: \"https://api.openai.com/v1/completions\",\n *     urlParams: [],\n *     hash: undefined,\n *     headers: { \"Content-Type\": \"application/json\" }\n *   },\n *   response: {\n *     status: 429,\n *     headers: { \"X-RateLimit-Remaining\": \"0\" }\n *   },\n *   description: \"Rate limit exceeded\"\n * })\n *\n * console.log(responseError.message)\n * // \"StatusCode: Rate limit exceeded (429 POST https://api.openai.com/v1/completions)\"\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class HttpResponseError extends Schema.ErrorClass<HttpResponseError>(\n  \"effect/ai/AiError/HttpResponseError\"\n)({\n  _tag: Schema.tag(\"HttpResponseError\"),\n  module: Schema.String,\n  method: Schema.String,\n  request: HttpRequestDetails,\n  response: HttpResponseDetails,\n  body: Schema.optional(Schema.String),\n  reason: Schema.Literals([\"StatusCode\", \"Decode\", \"EmptyBody\"]),\n  description: Schema.optional(Schema.String)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * Creates an HttpResponseError from a platform HttpClientError.ResponseError.\n   *\n   * @example\n   * ```ts\n   * import { AiError } from \"effect/unstable/ai\"\n   * import type { HttpClientError } from \"effect/unstable/http\"\n   *\n   * declare const platformError: HttpClientError.ResponseError\n   *\n   * const aiError = AiError.HttpResponseError.fromResponseError({\n   *   module: \"OpenAI\",\n   *   method: \"completion\",\n   *   error: platformError\n   * })\n   * ```\n   *\n   * @since 4.0.0\n   * @category constructors\n   */\n  static fromResponseError({ error, ...params }: {\n    readonly module: string\n    readonly method: string\n    readonly error: HttpClientError.ResponseError\n  }): Effect.Effect<never, HttpResponseError> {\n    let body: Effect.Effect<unknown, HttpClientError.ResponseError> = Effect.void\n    const contentType = error.response.headers[\"content-type\"] ?? \"\"\n    if (contentType.includes(\"application/json\")) {\n      body = error.response.json\n    } else if (contentType.includes(\"text/\") || contentType.includes(\"urlencoded\")) {\n      body = error.response.text\n    }\n    return Effect.flatMap(\n      Effect.matchEffect(body, {\n        onFailure: Effect.succeed,\n        onSuccess: Effect.succeed\n      }),\n      (body) =>\n        Effect.fail(\n          new HttpResponseError({\n            ...params,\n            description: error.description,\n            reason: error.reason,\n            request: {\n              hash: error.request.hash,\n              headers: redact(error.request.headers) as any,\n              method: error.request.method,\n              url: error.request.url,\n              urlParams: Array.from(error.request.urlParams)\n            },\n            response: {\n              headers: redact(error.response.headers) as any,\n              status: error.response.status\n            },\n            body: format(redact(body))\n          })\n        )\n    )\n  }\n\n  override get message(): string {\n    const methodUrlStatus = `${this.response.status} ${this.request.method} ${this.request.url}`\n\n    let baseMessage = this.description\n      ? `${this.reason}: ${this.description}`\n      : `${this.reason}: An HTTP response error occurred.`\n\n    baseMessage += ` (${methodUrlStatus})`\n\n    let suggestion = \"\"\n    switch (this.reason) {\n      case \"Decode\": {\n        suggestion += \"The response format does not match what is expected. \" +\n          \"Verify API version compatibility, check response content-type, \" +\n          \"and/or examine if the endpoint schema has changed.\"\n        break\n      }\n      case \"EmptyBody\": {\n        suggestion += \"The response body was empty. This may indicate a server \" +\n          \"issue, API version mismatch, or the endpoint may have changed its response format.\"\n        break\n      }\n      case \"StatusCode\": {\n        suggestion += getStatusCodeSuggestion(this.response.status)\n        break\n      }\n    }\n\n    baseMessage += `\\n\\n${suggestion}`\n\n    if (Predicate.isNotUndefined(this.body)) {\n      baseMessage += `\\n\\nResponse Body: ${this.body}`\n    }\n\n    return baseMessage\n  }\n}\n\n// =============================================================================\n// Malformed Input Error\n// =============================================================================\n\n/**\n * Error thrown when input data doesn't match the expected format or schema.\n *\n * This error occurs when the data provided to an AI operation fails validation,\n * is missing required fields, or doesn't conform to the expected structure.\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const validateInput = Effect.fnUntraced(function*(data: unknown) {\n *   if (typeof data === \"string\" && data.length > 0) {\n *     return data\n *   }\n *   return yield* new AiError.MalformedInput({\n *     module: \"ChatBot\",\n *     method: \"processMessage\",\n *     description: \"Input must be a non-empty string\"\n *   })\n * })\n *\n * const program = validateInput(\"\").pipe(\n *   Effect.catchTag(\"MalformedInput\", (error) => {\n *     console.log(`Input validation failed: ${error.description}`)\n *     return Effect.succeed(\"Please provide a valid message\")\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class MalformedInput extends Schema.ErrorClass<MalformedInput>(\n  \"effect/ai/AiError/MalformedInput\"\n)({\n  _tag: Schema.tag(\"MalformedInput\"),\n  module: Schema.String,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n}\n\n// =============================================================================\n// Malformed Output Error\n// =============================================================================\n\n/**\n * Error thrown when output data can't be parsed or validated.\n *\n * This error occurs when AI service responses don't match the expected format,\n * contain invalid data structures, or fail schema validation during parsing.\n *\n * @example\n * ```ts\n * import { Effect, Schema } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const ResponseSchema = Schema.Struct({\n *   message: Schema.String,\n *   tokens: Schema.Number\n * })\n *\n * const parseResponse = (data: unknown) =>\n *   Schema.decodeUnknownEffect(ResponseSchema)(data).pipe(\n *     Effect.mapError((schemaError) =>\n *       new AiError.MalformedOutput({\n *         module: \"OpenAI\",\n *         method: \"completion\",\n *         description: \"Response doesn't match expected schema\",\n *         cause: schemaError\n *       })\n *     )\n *   )\n *\n * const program = parseResponse({ invalid: \"data\" }).pipe(\n *   Effect.catchTag(\"MalformedOutput\", (error) => {\n *     console.log(`Parsing failed: ${error.description}`)\n *     return Effect.succeed({ message: \"Error\", tokens: 0 })\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class MalformedOutput extends Schema.ErrorClass<MalformedOutput>(\n  \"effect/ai/AiError/MalformedOutput\"\n)({\n  _tag: Schema.tag(\"MalformedOutput\"),\n  module: Schema.String,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * Creates a MalformedOutput error from a Schema ParseError.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   * import { AiError } from \"effect/unstable/ai\"\n   *\n   * const UserSchema = Schema.Struct({\n   *   name: Schema.String,\n   *   age: Schema.Number\n   * })\n   *\n   * const parseUser = (data: unknown) =>\n   *   Schema.decodeUnknownEffect(UserSchema)(data).pipe(\n   *     Effect.mapError((parseError) =>\n   *       AiError.MalformedOutput.fromSchemaError({\n   *         module: \"UserService\",\n   *         method: \"parseUserData\",\n   *         error: parseError\n   *       })\n   *     )\n   *   )\n   * ```\n   *\n   * @since 4.0.0\n   * @category constructors\n   */\n  static fromSchemaError({ error, ...params }: {\n    readonly module: string\n    readonly method: string\n    readonly description?: string\n    readonly error: Schema.SchemaError\n  }): MalformedOutput {\n    // TODO(Max): enhance\n    return new MalformedOutput({\n      ...params,\n      cause: error\n    })\n  }\n}\n\n// =============================================================================\n// Unknown Error\n// =============================================================================\n\n/**\n * Catch-all error for unexpected runtime errors in AI operations.\n *\n * This error is used when an unexpected exception occurs that doesn't fit\n * into the other specific error categories. It provides context about where\n * the error occurred and preserves the original cause for debugging.\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const riskyOperation = () => {\n *   try {\n *     // Some operation that might throw\n *     throw new Error(\"Unexpected network issue\")\n *   } catch (cause) {\n *     return Effect.fail(\n *       new AiError.UnknownError({\n *         module: \"ChatService\",\n *         method: \"sendMessage\",\n *         description: \"An unexpected error occurred during message processing\",\n *         cause\n *       })\n *     )\n *   }\n * }\n *\n * const program = riskyOperation().pipe(\n *   Effect.catchTag(\"UnknownError\", (error) => {\n *     console.log(error.message)\n *     // \"ChatService.sendMessage: An unexpected error occurred during message processing\"\n *     return Effect.succeed(\"Service temporarily unavailable\")\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class UnknownError extends Schema.ErrorClass<UnknownError>(\n  \"effect/ai/AiError/UnknownError\"\n)({\n  _tag: Schema.tag(\"UnknownError\"),\n  module: Schema.String,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * @since 4.0.0\n   */\n  override get message(): string {\n    const moduleMethod = `${this.module}.${this.method}`\n    return Predicate.isUndefined(this.description)\n      ? `${moduleMethod}: An error occurred`\n      : `${moduleMethod}: ${this.description}`\n  }\n}\n\n// =============================================================================\n// AiError\n// =============================================================================\n\n/**\n * Union type representing all possible AI operation errors.\n *\n * This type encompasses all error cases that can occur during AI operations,\n * providing a comprehensive error handling surface for applications.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const handleAnyAiError = Match.type<AiError.AiError>().pipe(\n *   Match.tag(\"HttpRequestError\", (err) => `Network error: ${err.reason}`),\n *   Match.tag(\n *     \"HttpResponseError\",\n *     (err) => `Server error: HTTP ${err.response.status}`\n *   ),\n *   Match.tag(\n *     \"MalformedInput\",\n *     (err) => `Invalid input: ${err.description || \"Data validation failed\"}`\n *   ),\n *   Match.tag(\n *     \"MalformedOutput\",\n *     (err) => `Invalid response: ${err.description || \"Response parsing failed\"}`\n *   ),\n *   Match.orElse((err) => `Unknown error: ${err.message}`)\n * )\n * ```\n *\n * @since 4.0.0\n * @category models\n */\nexport type AiError =\n  | HttpRequestError\n  | HttpResponseError\n  | MalformedInput\n  | MalformedOutput\n  | UnknownError\n\n/**\n * Schema for validating and parsing AI errors.\n *\n * This schema can be used to decode unknown values into properly typed AI\n * errors, ensuring type safety when handling errors from external sources or\n * serialized data.\n *\n * @example\n * ```ts\n * import { Effect, Schema } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const parseAiError = (data: unknown) =>\n *   Schema.decodeUnknownEffect(AiError.AiError)(data).pipe(\n *     Effect.map((error) => {\n *       console.log(`Parsed AI error: ${error._tag}`)\n *       return error\n *     }),\n *     Effect.catch(() =>\n *       Effect.succeed(\n *         new AiError.UnknownError({\n *           module: \"Parser\",\n *           method: \"parseAiError\",\n *           description: \"Failed to parse error data\"\n *         })\n *       )\n *     )\n *   )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const AiError: Schema.Union<[\n  typeof HttpRequestError,\n  typeof HttpResponseError,\n  typeof MalformedInput,\n  typeof MalformedOutput,\n  typeof UnknownError\n]> = Schema.Union([\n  HttpRequestError,\n  HttpResponseError,\n  MalformedInput,\n  MalformedOutput,\n  UnknownError\n])\n\n// =============================================================================\n// Utilities\n// =============================================================================\n\nconst getStatusCodeSuggestion = (statusCode: number): string => {\n  if (statusCode >= 400 && statusCode < 500) {\n    switch (statusCode) {\n      case 400:\n        return \"Bad Request - Check request parameters, headers, and body format against API documentation.\"\n      case 401:\n        return \"Unauthorized - Verify API key, authentication credentials, or token expiration.\"\n      case 403:\n        return \"Forbidden - Check API permissions, usage limits, or resource access rights.\"\n      case 404:\n        return \"Not Found - Verify the endpoint URL, API version, and resource identifiers.\"\n      case 408:\n        return \"Request Timeout - Consider increasing timeout duration or implementing retry logic.\"\n      case 422:\n        return \"Unprocessable Entity - Check request data validation, required fields, and data formats.\"\n      case 429:\n        return \"Rate Limited - Implement exponential backoff or reduce request frequency.\"\n      default:\n        return \"Client error - Review request format, parameters, and API documentation.\"\n    }\n  } else if (statusCode >= 500) {\n    return \"Server error - This is likely temporary. Implement retry logic with exponential backoff.\"\n  } else {\n    return \"Check API documentation for this status code.\"\n  }\n}\n","after":"/**\n * The `AiError` module provides comprehensive error handling for AI operations.\n *\n * This module defines a hierarchy of error types that can occur when working\n * with AI services, including HTTP request/response errors, input/output\n * validation errors, and general runtime errors. All errors follow Effect's\n * structured error patterns and provide detailed context for debugging.\n *\n * ## Error Types\n *\n * - **HttpRequestError**: Errors occurring during HTTP request processing\n * - **HttpResponseError**: Errors occurring during HTTP response processing\n * - **MalformedInput**: Errors when input data doesn't match expected format\n * - **MalformedOutput**: Errors when output data can't be parsed or validated\n * - **UnknownError**: Catch-all for unexpected runtime errors\n *\n * @example\n * ```ts\n * import { Effect, Match } from \"effect\"\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const handleAiError = Match.type<AiError.AiError>().pipe(\n *   Match.tag(\n *     \"HttpRequestError\",\n *     (err) => Effect.logError(`Request failed: ${err.message}`)\n *   ),\n *   Match.tag(\n *     \"HttpResponseError\",\n *     (err) =>\n *       Effect.logError(`Response error (${err.response.status}): ${err.message}`)\n *   ),\n *   Match.tag(\n *     \"MalformedInput\",\n *     (err) => Effect.logError(`Invalid input: ${err.message}`)\n *   ),\n *   Match.tag(\n *     \"MalformedOutput\",\n *     (err) => Effect.logError(`Invalid output: ${err.message}`)\n *   ),\n *   Match.orElse((err) => Effect.logError(`Unknown error: ${err.message}`))\n * )\n * ```\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const aiOperation = Effect.gen(function*() {\n *   // Some AI operation that might fail\n *   return yield* new AiError.HttpRequestError({\n *     module: \"OpenAI\",\n *     method: \"completion\",\n *     reason: \"Transport\",\n *     request: {\n *       method: \"POST\",\n *       url: \"https://api.openai.com/v1/completions\",\n *       urlParams: [],\n *       hash: undefined,\n *       headers: { \"Content-Type\": \"application/json\" }\n *     }\n *   })\n * })\n *\n * const program = aiOperation.pipe(\n *   Effect.catchTag(\"HttpRequestError\", (error) => {\n *     console.log(\"Request failed:\", error.message)\n *     return Effect.succeed(\"fallback response\")\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n */\nimport * as Effect from \"../../Effect.ts\"\nimport { format } from \"../../Formatter.ts\"\nimport * as Predicate from \"../../Predicate.ts\"\nimport { redact } from \"../../Redactable.ts\"\nimport * as Schema from \"../../Schema.ts\"\nimport type * as HttpClientError from \"../http/HttpClientError.ts\"\n\nconst TypeId = \"~effect/unstable/ai/AiError\" as const\n\n/**\n * Type guard to check if a value is an AI error.\n *\n * @param u - The value to check\n * @returns `true` if the value is an `AiError`, `false` otherwise\n *\n * @example\n * ```ts\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const someError = new Error(\"generic error\")\n * const aiError = new AiError.UnknownError({\n *   module: \"Test\",\n *   method: \"example\"\n * })\n *\n * console.log(AiError.isAiError(someError)) // false\n * console.log(AiError.isAiError(aiError)) // true\n * ```\n *\n * @since 4.0.0\n * @category guards\n */\nexport const isAiError = (u: unknown): u is AiError => Predicate.hasProperty(u, TypeId)\n\n// =============================================================================\n// Http Request Error\n// =============================================================================\n\n/**\n * Schema for HTTP request details used in error reporting.\n *\n * Captures comprehensive information about HTTP requests that failed,\n * enabling detailed error analysis and debugging.\n *\n * @example\n * ```ts\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const requestDetails: typeof AiError.HttpRequestDetails.Type = {\n *   method: \"POST\",\n *   url: \"https://api.openai.com/v1/completions\",\n *   urlParams: [[\"model\", \"gpt-4\"], [\"stream\", \"false\"]],\n *   hash: \"#section1\",\n *   headers: { \"Content-Type\": \"application/json\" }\n * }\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const HttpRequestDetails = Schema.Struct({\n  method: Schema.Literals([\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\"]),\n  url: Schema.String,\n  urlParams: Schema.Array(Schema.Tuple([Schema.String, Schema.String])),\n  hash: Schema.UndefinedOr(Schema.String),\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpRequestDetails\" })\n\n/**\n * Error that occurs during HTTP request processing.\n *\n * This error is raised when issues arise before receiving an HTTP response,\n * such as network connectivity problems, request encoding issues, or invalid\n * URLs.\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const handleNetworkError = Effect.gen(function*() {\n *   const error = new AiError.HttpRequestError({\n *     module: \"OpenAI\",\n *     method: \"createCompletion\",\n *     reason: \"Transport\",\n *     request: {\n *       method: \"POST\",\n *       url: \"https://api.openai.com/v1/completions\",\n *       urlParams: [],\n *       hash: undefined,\n *       headers: { \"Content-Type\": \"application/json\" }\n *     },\n *     description: \"Connection timeout after 30 seconds\"\n *   })\n *\n *   console.log(error.message)\n *   // \"Transport: Connection timeout after 30 seconds (POST https://api.openai.com/v1/completions)\"\n * })\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class HttpRequestError extends Schema.ErrorClass<HttpRequestError>(\n  \"effect/ai/AiError/HttpRequestError\"\n)({\n  _tag: Schema.tag(\"HttpRequestError\"),\n  module: Schema.String,\n  method: Schema.String,\n  reason: Schema.Literals([\"Transport\", \"Encode\", \"InvalidUrl\"]),\n  request: HttpRequestDetails,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * Creates an HttpRequestError from a platform HttpClientError.RequestError.\n   *\n   * @example\n   * ```ts\n   * import { AiError } from \"effect/unstable/ai\"\n   * import type { HttpClientError } from \"effect/unstable/http\"\n   *\n   * declare const platformError: HttpClientError.RequestError\n   *\n   * const aiError = AiError.HttpRequestError.fromRequestError({\n   *   module: \"ChatGPT\",\n   *   method: \"sendMessage\",\n   *   error: platformError\n   * })\n   * ```\n   *\n   * @since 4.0.0\n   * @category constructors\n   */\n  static fromRequestError({ error, ...params }: {\n    readonly module: string\n    readonly method: string\n    readonly error: HttpClientError.RequestError\n  }): HttpRequestError {\n    return new HttpRequestError({\n      ...params,\n      cause: error,\n      description: error.description,\n      reason: error.reason,\n      request: {\n        hash: error.request.hash,\n        headers: redact(error.request.headers) as any,\n        method: error.request.method,\n        url: error.request.url,\n        urlParams: Array.from(error.request.urlParams)\n      }\n    })\n  }\n\n  override get message(): string {\n    const methodAndUrl = `${this.request.method} ${this.request.url}`\n\n    let baseMessage = this.description\n      ? `${this.reason}: ${this.description}`\n      : `${this.reason}: An HTTP request error occurred.`\n\n    baseMessage += ` (${methodAndUrl})`\n\n    let suggestion = \"\"\n    switch (this.reason) {\n      case \"Encode\": {\n        suggestion += \"Check that the request body data is properly formatted and matches the expected content type.\"\n        break\n      }\n\n      case \"InvalidUrl\": {\n        suggestion += \"Verify that the URL format is correct and that all required parameters have been provided.\"\n        suggestion += \" Check for any special characters that may need encoding.\"\n        break\n      }\n\n      case \"Transport\": {\n        suggestion += \"Check your network connection and verify that the requested URL is accessible.\"\n        break\n      }\n    }\n\n    baseMessage += `\\n\\n${suggestion}`\n\n    return baseMessage\n  }\n}\n\n// =============================================================================\n// Http Response Error\n// =============================================================================\n\n/**\n * Schema for HTTP response details used in error reporting.\n *\n * Captures essential information about HTTP responses that caused errors,\n * including status codes and headers for debugging purposes.\n *\n * @example\n * ```ts\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const responseDetails: typeof AiError.HttpResponseDetails.Type = {\n *   status: 429,\n *   headers: {\n *     \"Content-Type\": \"application/json\",\n *     \"X-RateLimit-Remaining\": \"0\",\n *     \"Retry-After\": \"60\"\n *   }\n * }\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const HttpResponseDetails = Schema.Struct({\n  status: Schema.Number,\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpResponseDetails\" })\n\n// =============================================================================\n// Supporting Schemas\n// =============================================================================\n\n/**\n * Metadata about the AI provider that originated an error.\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const ProviderMetadata = Schema.Struct({\n  name: Schema.String,\n  errorCode: Schema.optional(Schema.String),\n  errorType: Schema.optional(Schema.String),\n  requestId: Schema.optional(Schema.String),\n  raw: Schema.optional(Schema.Unknown)\n}).annotate({ identifier: \"ProviderMetadata\" })\n\n/**\n * Token usage information from AI operations.\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const UsageInfo = Schema.Struct({\n  promptTokens: Schema.optional(Schema.Number),\n  completionTokens: Schema.optional(Schema.Number),\n  totalTokens: Schema.optional(Schema.Number)\n}).annotate({ identifier: \"UsageInfo\" })\n\n/**\n * Combined HTTP context for error reporting.\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const HttpContext = Schema.Struct({\n  request: HttpRequestDetails,\n  response: Schema.optional(HttpResponseDetails),\n  body: Schema.optional(Schema.String)\n}).annotate({ identifier: \"HttpContext\" })\n\n/**\n * Error that occurs during HTTP response processing.\n *\n * This error is thrown when issues arise after receiving an HTTP response,\n * such as unexpected status codes, response decoding failures, or empty\n * response bodies.\n *\n * @example\n * ```ts\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const responseError = new AiError.HttpResponseError({\n *   module: \"OpenAI\",\n *   method: \"createCompletion\",\n *   reason: \"StatusCode\",\n *   request: {\n *     method: \"POST\",\n *     url: \"https://api.openai.com/v1/completions\",\n *     urlParams: [],\n *     hash: undefined,\n *     headers: { \"Content-Type\": \"application/json\" }\n *   },\n *   response: {\n *     status: 429,\n *     headers: { \"X-RateLimit-Remaining\": \"0\" }\n *   },\n *   description: \"Rate limit exceeded\"\n * })\n *\n * console.log(responseError.message)\n * // \"StatusCode: Rate limit exceeded (429 POST https://api.openai.com/v1/completions)\"\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class HttpResponseError extends Schema.ErrorClass<HttpResponseError>(\n  \"effect/ai/AiError/HttpResponseError\"\n)({\n  _tag: Schema.tag(\"HttpResponseError\"),\n  module: Schema.String,\n  method: Schema.String,\n  request: HttpRequestDetails,\n  response: HttpResponseDetails,\n  body: Schema.optional(Schema.String),\n  reason: Schema.Literals([\"StatusCode\", \"Decode\", \"EmptyBody\"]),\n  description: Schema.optional(Schema.String)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * Creates an HttpResponseError from a platform HttpClientError.ResponseError.\n   *\n   * @example\n   * ```ts\n   * import { AiError } from \"effect/unstable/ai\"\n   * import type { HttpClientError } from \"effect/unstable/http\"\n   *\n   * declare const platformError: HttpClientError.ResponseError\n   *\n   * const aiError = AiError.HttpResponseError.fromResponseError({\n   *   module: \"OpenAI\",\n   *   method: \"completion\",\n   *   error: platformError\n   * })\n   * ```\n   *\n   * @since 4.0.0\n   * @category constructors\n   */\n  static fromResponseError({ error, ...params }: {\n    readonly module: string\n    readonly method: string\n    readonly error: HttpClientError.ResponseError\n  }): Effect.Effect<never, HttpResponseError> {\n    let body: Effect.Effect<unknown, HttpClientError.ResponseError> = Effect.void\n    const contentType = error.response.headers[\"content-type\"] ?? \"\"\n    if (contentType.includes(\"application/json\")) {\n      body = error.response.json\n    } else if (contentType.includes(\"text/\") || contentType.includes(\"urlencoded\")) {\n      body = error.response.text\n    }\n    return Effect.flatMap(\n      Effect.matchEffect(body, {\n        onFailure: Effect.succeed,\n        onSuccess: Effect.succeed\n      }),\n      (body) =>\n        Effect.fail(\n          new HttpResponseError({\n            ...params,\n            description: error.description,\n            reason: error.reason,\n            request: {\n              hash: error.request.hash,\n              headers: redact(error.request.headers) as any,\n              method: error.request.method,\n              url: error.request.url,\n              urlParams: Array.from(error.request.urlParams)\n            },\n            response: {\n              headers: redact(error.response.headers) as any,\n              status: error.response.status\n            },\n            body: format(redact(body))\n          })\n        )\n    )\n  }\n\n  override get message(): string {\n    const methodUrlStatus = `${this.response.status} ${this.request.method} ${this.request.url}`\n\n    let baseMessage = this.description\n      ? `${this.reason}: ${this.description}`\n      : `${this.reason}: An HTTP response error occurred.`\n\n    baseMessage += ` (${methodUrlStatus})`\n\n    let suggestion = \"\"\n    switch (this.reason) {\n      case \"Decode\": {\n        suggestion += \"The response format does not match what is expected. \" +\n          \"Verify API version compatibility, check response content-type, \" +\n          \"and/or examine if the endpoint schema has changed.\"\n        break\n      }\n      case \"EmptyBody\": {\n        suggestion += \"The response body was empty. This may indicate a server \" +\n          \"issue, API version mismatch, or the endpoint may have changed its response format.\"\n        break\n      }\n      case \"StatusCode\": {\n        suggestion += getStatusCodeSuggestion(this.response.status)\n        break\n      }\n    }\n\n    baseMessage += `\\n\\n${suggestion}`\n\n    if (Predicate.isNotUndefined(this.body)) {\n      baseMessage += `\\n\\nResponse Body: ${this.body}`\n    }\n\n    return baseMessage\n  }\n}\n\n// =============================================================================\n// Malformed Input Error\n// =============================================================================\n\n/**\n * Error thrown when input data doesn't match the expected format or schema.\n *\n * This error occurs when the data provided to an AI operation fails validation,\n * is missing required fields, or doesn't conform to the expected structure.\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const validateInput = Effect.fnUntraced(function*(data: unknown) {\n *   if (typeof data === \"string\" && data.length > 0) {\n *     return data\n *   }\n *   return yield* new AiError.MalformedInput({\n *     module: \"ChatBot\",\n *     method: \"processMessage\",\n *     description: \"Input must be a non-empty string\"\n *   })\n * })\n *\n * const program = validateInput(\"\").pipe(\n *   Effect.catchTag(\"MalformedInput\", (error) => {\n *     console.log(`Input validation failed: ${error.description}`)\n *     return Effect.succeed(\"Please provide a valid message\")\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class MalformedInput extends Schema.ErrorClass<MalformedInput>(\n  \"effect/ai/AiError/MalformedInput\"\n)({\n  _tag: Schema.tag(\"MalformedInput\"),\n  module: Schema.String,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n}\n\n// =============================================================================\n// Malformed Output Error\n// =============================================================================\n\n/**\n * Error thrown when output data can't be parsed or validated.\n *\n * This error occurs when AI service responses don't match the expected format,\n * contain invalid data structures, or fail schema validation during parsing.\n *\n * @example\n * ```ts\n * import { Effect, Schema } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const ResponseSchema = Schema.Struct({\n *   message: Schema.String,\n *   tokens: Schema.Number\n * })\n *\n * const parseResponse = (data: unknown) =>\n *   Schema.decodeUnknownEffect(ResponseSchema)(data).pipe(\n *     Effect.mapError((schemaError) =>\n *       new AiError.MalformedOutput({\n *         module: \"OpenAI\",\n *         method: \"completion\",\n *         description: \"Response doesn't match expected schema\",\n *         cause: schemaError\n *       })\n *     )\n *   )\n *\n * const program = parseResponse({ invalid: \"data\" }).pipe(\n *   Effect.catchTag(\"MalformedOutput\", (error) => {\n *     console.log(`Parsing failed: ${error.description}`)\n *     return Effect.succeed({ message: \"Error\", tokens: 0 })\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class MalformedOutput extends Schema.ErrorClass<MalformedOutput>(\n  \"effect/ai/AiError/MalformedOutput\"\n)({\n  _tag: Schema.tag(\"MalformedOutput\"),\n  module: Schema.String,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * Creates a MalformedOutput error from a Schema ParseError.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   * import { AiError } from \"effect/unstable/ai\"\n   *\n   * const UserSchema = Schema.Struct({\n   *   name: Schema.String,\n   *   age: Schema.Number\n   * })\n   *\n   * const parseUser = (data: unknown) =>\n   *   Schema.decodeUnknownEffect(UserSchema)(data).pipe(\n   *     Effect.mapError((parseError) =>\n   *       AiError.MalformedOutput.fromSchemaError({\n   *         module: \"UserService\",\n   *         method: \"parseUserData\",\n   *         error: parseError\n   *       })\n   *     )\n   *   )\n   * ```\n   *\n   * @since 4.0.0\n   * @category constructors\n   */\n  static fromSchemaError({ error, ...params }: {\n    readonly module: string\n    readonly method: string\n    readonly description?: string\n    readonly error: Schema.SchemaError\n  }): MalformedOutput {\n    // TODO(Max): enhance\n    return new MalformedOutput({\n      ...params,\n      cause: error\n    })\n  }\n}\n\n// =============================================================================\n// Unknown Error\n// =============================================================================\n\n/**\n * Catch-all error for unexpected runtime errors in AI operations.\n *\n * This error is used when an unexpected exception occurs that doesn't fit\n * into the other specific error categories. It provides context about where\n * the error occurred and preserves the original cause for debugging.\n *\n * @example\n * ```ts\n * import { Effect } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const riskyOperation = () => {\n *   try {\n *     // Some operation that might throw\n *     throw new Error(\"Unexpected network issue\")\n *   } catch (cause) {\n *     return Effect.fail(\n *       new AiError.UnknownError({\n *         module: \"ChatService\",\n *         method: \"sendMessage\",\n *         description: \"An unexpected error occurred during message processing\",\n *         cause\n *       })\n *     )\n *   }\n * }\n *\n * const program = riskyOperation().pipe(\n *   Effect.catchTag(\"UnknownError\", (error) => {\n *     console.log(error.message)\n *     // \"ChatService.sendMessage: An unexpected error occurred during message processing\"\n *     return Effect.succeed(\"Service temporarily unavailable\")\n *   })\n * )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport class UnknownError extends Schema.ErrorClass<UnknownError>(\n  \"effect/ai/AiError/UnknownError\"\n)({\n  _tag: Schema.tag(\"UnknownError\"),\n  module: Schema.String,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 4.0.0\n   */\n  readonly [TypeId] = TypeId\n\n  /**\n   * @since 4.0.0\n   */\n  override get message(): string {\n    const moduleMethod = `${this.module}.${this.method}`\n    return Predicate.isUndefined(this.description)\n      ? `${moduleMethod}: An error occurred`\n      : `${moduleMethod}: ${this.description}`\n  }\n}\n\n// =============================================================================\n// AiError\n// =============================================================================\n\n/**\n * Union type representing all possible AI operation errors.\n *\n * This type encompasses all error cases that can occur during AI operations,\n * providing a comprehensive error handling surface for applications.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n * import type { AiError } from \"effect/unstable/ai\"\n *\n * const handleAnyAiError = Match.type<AiError.AiError>().pipe(\n *   Match.tag(\"HttpRequestError\", (err) => `Network error: ${err.reason}`),\n *   Match.tag(\n *     \"HttpResponseError\",\n *     (err) => `Server error: HTTP ${err.response.status}`\n *   ),\n *   Match.tag(\n *     \"MalformedInput\",\n *     (err) => `Invalid input: ${err.description || \"Data validation failed\"}`\n *   ),\n *   Match.tag(\n *     \"MalformedOutput\",\n *     (err) => `Invalid response: ${err.description || \"Response parsing failed\"}`\n *   ),\n *   Match.orElse((err) => `Unknown error: ${err.message}`)\n * )\n * ```\n *\n * @since 4.0.0\n * @category models\n */\nexport type AiError =\n  | HttpRequestError\n  | HttpResponseError\n  | MalformedInput\n  | MalformedOutput\n  | UnknownError\n\n/**\n * Schema for validating and parsing AI errors.\n *\n * This schema can be used to decode unknown values into properly typed AI\n * errors, ensuring type safety when handling errors from external sources or\n * serialized data.\n *\n * @example\n * ```ts\n * import { Effect, Schema } from \"effect\"\n * import { AiError } from \"effect/unstable/ai\"\n *\n * const parseAiError = (data: unknown) =>\n *   Schema.decodeUnknownEffect(AiError.AiError)(data).pipe(\n *     Effect.map((error) => {\n *       console.log(`Parsed AI error: ${error._tag}`)\n *       return error\n *     }),\n *     Effect.catch(() =>\n *       Effect.succeed(\n *         new AiError.UnknownError({\n *           module: \"Parser\",\n *           method: \"parseAiError\",\n *           description: \"Failed to parse error data\"\n *         })\n *       )\n *     )\n *   )\n * ```\n *\n * @since 4.0.0\n * @category schemas\n */\nexport const AiError: Schema.Union<[\n  typeof HttpRequestError,\n  typeof HttpResponseError,\n  typeof MalformedInput,\n  typeof MalformedOutput,\n  typeof UnknownError\n]> = Schema.Union([\n  HttpRequestError,\n  HttpResponseError,\n  MalformedInput,\n  MalformedOutput,\n  UnknownError\n])\n\n// =============================================================================\n// Utilities\n// =============================================================================\n\nconst getStatusCodeSuggestion = (statusCode: number): string => {\n  if (statusCode >= 400 && statusCode < 500) {\n    switch (statusCode) {\n      case 400:\n        return \"Bad Request - Check request parameters, headers, and body format against API documentation.\"\n      case 401:\n        return \"Unauthorized - Verify API key, authentication credentials, or token expiration.\"\n      case 403:\n        return \"Forbidden - Check API permissions, usage limits, or resource access rights.\"\n      case 404:\n        return \"Not Found - Verify the endpoint URL, API version, and resource identifiers.\"\n      case 408:\n        return \"Request Timeout - Consider increasing timeout duration or implementing retry logic.\"\n      case 422:\n        return \"Unprocessable Entity - Check request data validation, required fields, and data formats.\"\n      case 429:\n        return \"Rate Limited - Implement exponential backoff or reduce request frequency.\"\n      default:\n        return \"Client error - Review request format, parameters, and API documentation.\"\n    }\n  } else if (statusCode >= 500) {\n    return \"Server error - This is likely temporary. Implement retry logic with exponential backoff.\"\n  } else {\n    return \"Check API documentation for this status code.\"\n  }\n}\n","additions":42,"deletions":0},"truncated":false},"time":{"start":1768774469861,"end":1768774470192}}}}
{"type":"step_finish","timestamp":1768774470255,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c8a32001rnyPskuK96DfOK","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c6a02001ZEGWcum55hrJFr","type":"step-finish","reason":"tool-calls","snapshot":"8a623ca64d6cdd7e63f128ea400209942f4f3bbb","cost":0,"tokens":{"input":0,"output":562,"reasoning":0,"cache":{"read":45393,"write":844}}}}
{"type":"step_start","timestamp":1768774472797,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c945c0014N0Cs7WlbWP6mG","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c8aa7001JgvPGamh3tCIVN","type":"step-start","snapshot":"9849b3045e5876527d65b554399415f1386ce9c0"}}
{"type":"tool_use","timestamp":1768774474857,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c945c002HDeaTDzhg3YA6Y","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c8aa7001JgvPGamh3tCIVN","type":"tool","callID":"toolu_01FUqz8yNYK7sJpKYhQbAAYG","tool":"bash","state":{"status":"completed","input":{"command":"pnpm lint-fix 2>&1 | tail -20","description":"Run lint-fix"},"output":"\n> @ lint-fix /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1\n> oxlint --fix && dprint fmt\n\nWARNING: JS plugins are experimental and not subject to semver.\nBreaking changes are possible while JS plugins support is under development.\nFound 0 warnings and 0 errors.\nFinished in 1.1s on 812 files using 10 threads.\nFormatted \u001b[1m1\u001b[0m file.\n","title":"Run lint-fix","metadata":{"output":"\n> @ lint-fix /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1\n> oxlint --fix && dprint fmt\n\nWARNING: JS plugins are experimental and not subject to semver.\nBreaking changes are possible while JS plugins support is under development.\nFound 0 warnings and 0 errors.\nFinished in 1.1s on 812 files using 10 threads.\nFormatted \u001b[1m1\u001b[0m file.\n","exit":0,"description":"Run lint-fix","truncated":false},"time":{"start":1768774473320,"end":1768774474856}}}}
{"type":"step_finish","timestamp":1768774474898,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32c9c690015zGMab7NrEbTMJ","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c8aa7001JgvPGamh3tCIVN","type":"step-finish","reason":"tool-calls","snapshot":"2f87fca32face318bb0770c6616b4b008839cfb5","cost":0,"tokens":{"input":0,"output":88,"reasoning":0,"cache":{"read":46237,"write":577}}}}
{"type":"step_start","timestamp":1768774477238,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32ca5b5001qq1CNTdS1xhLBD","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c9cc9001loR1LSXvBAh02C","type":"step-start","snapshot":"cd566163f4fa7fbbb0f67dc386644039276d21f4"}}
{"type":"tool_use","timestamp":1768774482694,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32ca5b6001ZynlP55B8ur5A5","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c9cc9001loR1LSXvBAh02C","type":"tool","callID":"toolu_015MvGC4djD8vESdfw5DDh8u","tool":"bash","state":{"status":"completed","input":{"command":"pnpm check 2>&1 | tail -30","description":"Run type checking"},"output":"\n> @ check /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1\n> tspc -b tsconfig.json\n\n","title":"Run type checking","metadata":{"output":"\n> @ check /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1\n> tspc -b tsconfig.json\n\n","exit":0,"description":"Run type checking","truncated":false},"time":{"start":1768774477695,"end":1768774482694}}}}
{"type":"step_finish","timestamp":1768774482735,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cbb06001Zhcp6tdKhgy5Il","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32c9cc9001loR1LSXvBAh02C","type":"step-finish","reason":"tool-calls","snapshot":"d24581ce4585165e0fecf69faa84dedf40f01c6f","cost":0,"tokens":{"input":0,"output":85,"reasoning":0,"cache":{"read":46814,"write":215}}}}
{"type":"step_start","timestamp":1768774484840,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cc367001fHnnIrK6jsFt1W","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cbb6c001KEFEaRsNB5MxI1","type":"step-start","snapshot":"78dc9c6b5cdfeb5b8437edbd0d76937abb18e004"}}
{"type":"text","timestamp":1768774485296,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cc368001iKxKbTzVxrX2Rf","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cbb6c001KEFEaRsNB5MxI1","type":"text","text":"Phase 1 is complete. Let me update the spec and todo list:","time":{"start":1768774485294,"end":1768774485294}}}
{"type":"tool_use","timestamp":1768774486402,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cc530001QlA2bJvmZjdRmS","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cbb6c001KEFEaRsNB5MxI1","type":"tool","callID":"toolu_01YBTwTJYJKMqaC2bmRGeyLw","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.specs/AI_ERROR_DOMAIN_MODEL.md","offset":640,"limit":30},"output":"<file>\n00641| \n00642| **Goal**: Define foundational schemas for metadata and context.\n00643| \n00644| **Files to modify**:\n00645| \n00646| - `packages/effect/src/unstable/ai/AiError.ts`\n00647| \n00648| **Tasks**:\n00649| \n00650| - [ ] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n00651| - [ ] **1.2** Add `UsageInfo` schema with token count fields\n00652| - [ ] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n00653| - [ ] **1.4** Keep existing `HttpResponseDetails` schema\n00654| - [ ] **1.5** Add `HttpContext` schema combining request/response/body\n00655| - [ ] **1.6** Run `pnpm lint-fix`\n00656| - [ ] **1.7** Run `pnpm check`\n00657| \n00658| **Verification**: `pnpm check` passes\n00659| \n00660| ### Phase 2: Reason Classes (Part 1)\n00661| \n00662| **Goal**: Implement first batch of semantic reason types.\n00663| \n00664| **Files to modify**:\n00665| \n00666| - `packages/effect/src/unstable/ai/AiError.ts`\n00667| \n00668| **Tasks**:\n00669| \n00670| - [ ] **2.1** Create `RateLimitError` with `isRetryable` getter (returns `true`), `retryAfter: Duration`, `limit`, `remaining`, `resetAt`\n\n(File has more lines. Use 'offset' parameter to read beyond line 670)\n</file>","title":".specs/AI_ERROR_DOMAIN_MODEL.md","metadata":{"preview":"\n**Goal**: Define foundational schemas for metadata and context.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n- [ ] **1.2** Add `UsageInfo` schema with token count fields\n- [ ] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n- [ ] **1.4** Keep existing `HttpResponseDetails` schema\n- [ ] **1.5** Add `HttpContext` schema combining request/response/body\n- [ ] **1.6** Run `pnpm lint-fix`\n- [ ] **1.7** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 2: Reason Classes (Part 1)","truncated":true},"time":{"start":1768774486396,"end":1768774486402}}}}
{"type":"step_finish","timestamp":1768774486493,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cc9aa001g9iyJOYu4CvFG0","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cbb6c001KEFEaRsNB5MxI1","type":"step-finish","reason":"tool-calls","snapshot":"0f5d81e4aee4b87b3e545b509f504578112e45bf","cost":0,"tokens":{"input":0,"output":144,"reasoning":0,"cache":{"read":47029,"write":138}}}}
{"type":"step_start","timestamp":1768774488959,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cd37e001kUj110uVPndfbR","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cca17001bfzJ1ownZz4AlG","type":"step-start","snapshot":"4fc1e77f7756f90a308ffc11c079d5a414f86894"}}
{"type":"tool_use","timestamp":1768774491957,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cd37f00183B552fn4IDpQP","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cca17001bfzJ1ownZz4AlG","type":"tool","callID":"toolu_01Nc8oJ2rxLPGyAHbXh3zXSS","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.specs/AI_ERROR_DOMAIN_MODEL.md","oldString":"**Tasks**:\n\n- [ ] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n- [ ] **1.2** Add `UsageInfo` schema with token count fields\n- [ ] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n- [ ] **1.4** Keep existing `HttpResponseDetails` schema\n- [ ] **1.5** Add `HttpContext` schema combining request/response/body\n- [ ] **1.6** Run `pnpm lint-fix`\n- [ ] **1.7** Run `pnpm check`\n\n**Verification**: `pnpm check` passes","newString":"**Tasks**:\n\n- [x] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n- [x] **1.2** Add `UsageInfo` schema with token count fields\n- [x] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n- [x] **1.4** Keep existing `HttpResponseDetails` schema\n- [x] **1.5** Add `HttpContext` schema combining request/response/body\n- [x] **1.6** Run `pnpm lint-fix`\n- [x] **1.7** Run `pnpm check`\n\n**Verification**: `pnpm check` passes"},"output":"Edit applied successfully.","title":".specs/AI_ERROR_DOMAIN_MODEL.md","metadata":{"diagnostics":{"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/packages/effect/src/unstable/ai/AiError.ts":[{"range":{"start":{"line":225,"character":50},"end":{"line":225,"character":53}},"severity":2,"code":"no-explicit-any","source":"deno-lint","message":"`any` type is not allowed\nUse a specific type other than `any`"},{"range":{"start":{"line":439,"character":56},"end":{"line":439,"character":59}},"severity":2,"code":"no-explicit-any","source":"deno-lint","message":"`any` type is not allowed\nUse a specific type other than `any`"},{"range":{"start":{"line":445,"character":57},"end":{"line":445,"character":60}},"severity":2,"code":"no-explicit-any","source":"deno-lint","message":"`any` type is not allowed\nUse a specific type other than `any`"}]},"diff":"Index: /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.specs/AI_ERROR_DOMAIN_MODEL.md\n===================================================================\n--- /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.specs/AI_ERROR_DOMAIN_MODEL.md\n+++ /Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.specs/AI_ERROR_DOMAIN_MODEL.md\n@@ -646,15 +646,15 @@\n - `packages/effect/src/unstable/ai/AiError.ts`\n \n **Tasks**:\n \n-- [ ] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n-- [ ] **1.2** Add `UsageInfo` schema with token count fields\n-- [ ] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n-- [ ] **1.4** Keep existing `HttpResponseDetails` schema\n-- [ ] **1.5** Add `HttpContext` schema combining request/response/body\n-- [ ] **1.6** Run `pnpm lint-fix`\n-- [ ] **1.7** Run `pnpm check`\n+- [x] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n+- [x] **1.2** Add `UsageInfo` schema with token count fields\n+- [x] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n+- [x] **1.4** Keep existing `HttpResponseDetails` schema\n+- [x] **1.5** Add `HttpContext` schema combining request/response/body\n+- [x] **1.6** Run `pnpm lint-fix`\n+- [x] **1.7** Run `pnpm check`\n \n **Verification**: `pnpm check` passes\n \n ### Phase 2: Reason Classes (Part 1)\n","filediff":{"file":"/Users/maxwellbrown/conductor/workspaces/effect-smol/cape-town-v1/.specs/AI_ERROR_DOMAIN_MODEL.md","before":"# AI Error Domain Model\n\n**Status: DRAFT**\n\n## Overview\n\nReplace the current `AiError` design with a comprehensive, provider-agnostic domain model for errors originating from large language model providers. The new design uses the `reason` pattern (see `Effect.catchReason`) where `AiError` is a top-level wrapper error containing `module`, `method`, and a `reason` field that holds the semantic error.\n\n## Problem Statement / Motivation\n\n### Current Limitations\n\n1. **Transport-centric errors**: Current errors (`HttpRequestError`, `HttpResponseError`) focus on HTTP mechanics, not AI-specific failure modes\n2. **Missing semantic categories**: No distinction between rate limiting, quota exhaustion, content policy violations, model availability, etc.\n3. **Poor retry guidance**: Errors don't indicate whether retrying is appropriate or provide backoff hints\n4. **Limited provider context**: No structured way to capture provider-specific error codes or metadata\n5. **No cost/usage context**: Errors don't capture token usage or cost information when available\n6. **Weak recoverability signals**: Callers can't easily determine if an error is transient vs permanent\n7. **Bad naming**: `MalformedInput` is unclear and doesn't convey semantic meaning\n\n### Goals\n\n- **Semantic error categories** that map to LLM-specific failure modes\n- **Provider-agnostic** design that works across OpenAI, Anthropic, Google, etc.\n- **Rich context** including retry hints, provider error codes, usage data\n- **Recoverability classification** (transient vs permanent)\n- **Actionable error messages** with specific remediation guidance\n- **Leverage `reason` pattern** for ergonomic error handling via `Effect.catchReason`\n\n## Design Decisions\n\n### 1. Schema.ErrorClass with `_tag` via Schema.tag\n\nAll errors use `Schema.ErrorClass` with `_tag` defined via `Schema.tag(\"...\")`:\n\n```typescript\nexport class RateLimitError extends Schema.ErrorClass<RateLimitError>(\n  \"effect/ai/AiError/RateLimitError\"\n)({\n  _tag: Schema.tag(\"RateLimitError\")\n  // ... fields\n}) {}\n```\n\n### 2. `reason` Pattern with Top-Level AiError\n\nUse the `reason` pattern recently introduced in Effect (see `Effect.catchReason`, `Effect.unwrapReason`). `AiError` is the top-level error with `module`, `method`, and `reason`:\n\n```typescript\nclass AiError extends Schema.ErrorClass<AiError>(\"effect/ai/AiError\")({\n  _tag: Schema.tag(\"AiError\"),\n  module: Schema.String,\n  method: Schema.String,\n  reason: AiErrorReason // Union of all semantic error types\n}) {}\n```\n\nThis enables:\n\n```typescript\n// Handle specific reason types\nprogram.pipe(\n  Effect.catchReason(\"AiError\", \"RateLimitError\", (reason) => Effect.succeed(`Retry after ${reason.retryAfter}`))\n)\n\n// Handle multiple reasons\nprogram.pipe(\n  Effect.catchReasons(\"AiError\", {\n    RateLimitError: (r) => Effect.succeed(`Retry after ${r.retryAfter}`),\n    QuotaExhaustedError: (r) => Effect.fail(new BillingError())\n  })\n)\n\n// Unwrap reason to error channel\nprogram.pipe(Effect.unwrapReason(\"AiError\"))\n// Effect<A, AiError> -> Effect<A, RateLimitError | QuotaExhaustedError | ...>\n```\n\n### 3. Provider-Specific Mapping in Provider Packages\n\nProvider-specific error mapping (e.g., OpenAI error codes -> semantic reasons) lives in provider packages, not in the core `AiError` module. The core module provides:\n\n- Semantic reason types\n- Base `AiError` wrapper\n- Generic HTTP -> reason mapping utilities\n\nProvider packages implement:\n\n- Provider-specific error code mapping\n- Custom reason construction from provider responses\n\n### 4. Semantic Error Categories\n\nMap provider errors to semantic categories:\n\n- `RateLimitError` - Request throttled (429s, provider-specific limits)\n- `QuotaExhaustedError` - Account/billing limits reached\n- `AuthenticationError` - Invalid/expired credentials\n- `ContentPolicyError` - Input/output violated content policy\n- `ModelUnavailableError` - Model not available/deprecated\n- `ContextLengthError` - Token limit exceeded\n- `InvalidRequestError` - Malformed request parameters (replaces `MalformedInput`)\n- `ProviderInternalError` - Provider-side failures (5xx)\n- `TimeoutError` - Request timeout (no streaming-specific types)\n- `NetworkError` - Transport-level failures\n- `OutputParseError` - LLM output parsing failures\n- `UnknownError` - Catch-all\n\n### 5. Recoverability Classification\n\nEach reason has an `isRetryable` getter that computes retryability based on the error state:\n\n```typescript\nget isRetryable(): boolean {\n  return true  // or computed based on error properties\n}\nreadonly retryAfter?: Duration  // Effect Duration type, when retry is recommended\n```\n\nThis approach:\n\n- Avoids redundant stored state\n- Allows retryability to be computed from other fields (e.g., `ModelUnavailableError` is retryable only if `kind` is `\"Overloaded\"` or `\"Maintenance\"`)\n- Keeps the schema simpler (no need for `Schema.Literal(true).withDefault()`)\n\n### 6. ContentPolicyError Includes Flagged Content\n\nWhen available, include the flagged content for debugging:\n\n```typescript\nflaggedContent: Schema.optional(Schema.String) // The actual content that was flagged\n```\n\n### 7. No Streaming-Specific Error Types\n\nStreaming errors map to existing reason types:\n\n- Stream timeout -> `TimeoutError`\n- Stream interrupted -> `NetworkError`\n- Partial response -> `OutputParseError` or `ProviderInternalError`\n\n## Technical Details\n\n### Top-Level AiError\n\n```typescript\nconst TypeId = \"~effect/unstable/ai/AiError\" as const\n\nexport class AiError extends Schema.ErrorClass<AiError>(\"effect/ai/AiError\")({\n  _tag: Schema.tag(\"AiError\"),\n  module: Schema.String,\n  method: Schema.String,\n  reason: AiErrorReason\n}) {\n  readonly [TypeId] = TypeId\n\n  /**\n   * Delegates to the underlying reason's isRetryable getter.\n   */\n  get isRetryable(): boolean {\n    return this.reason.isRetryable\n  }\n\n  /**\n   * Delegates to the underlying reason's retryAfter if present.\n   */\n  get retryAfter(): Duration | undefined {\n    return \"retryAfter\" in this.reason ? this.reason.retryAfter : undefined\n  }\n\n  override get message(): string {\n    return `${this.module}.${this.method}: ${this.reason.message}`\n  }\n}\n\nexport const isAiError = (u: unknown): u is AiError => Predicate.hasProperty(u, TypeId)\n```\n\n### Reason Type Definitions\n\n#### RateLimitError\n\n```typescript\nexport class RateLimitError extends Schema.ErrorClass<RateLimitError>(\n  \"effect/ai/AiError/RateLimitError\"\n)({\n  _tag: Schema.tag(\"RateLimitError\"),\n  retryAfter: Schema.optional(Schema.Duration),\n  limit: Schema.optional(Schema.String), // \"requests\" | \"tokens\" | etc.\n  remaining: Schema.optional(Schema.Number),\n  resetAt: Schema.optional(Schema.DateTimeUtc),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true\n  }\n\n  override get message(): string {\n    let msg = `Rate limit exceeded`\n    if (this.limit) msg += ` (${this.limit})`\n    if (this.retryAfter) msg += `. Retry after ${Duration.format(this.retryAfter)}`\n    return msg\n  }\n}\n```\n\n#### QuotaExhaustedError\n\n```typescript\nexport class QuotaExhaustedError extends Schema.ErrorClass<QuotaExhaustedError>(\n  \"effect/ai/AiError/QuotaExhaustedError\"\n)({\n  _tag: Schema.tag(\"QuotaExhaustedError\"),\n  quotaType: Schema.optional(Schema.String), // \"tokens\" | \"requests\" | \"spend\"\n  resetAt: Schema.optional(Schema.DateTimeUtc),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false\n  }\n\n  override get message(): string {\n    let msg = `Quota exhausted`\n    if (this.quotaType) msg += ` (${this.quotaType})`\n    if (this.resetAt) msg += `. Resets at ${this.resetAt}`\n    return `${msg}. Check your account billing and usage limits.`\n  }\n}\n```\n\n#### AuthenticationError\n\n```typescript\nexport class AuthenticationError extends Schema.ErrorClass<AuthenticationError>(\n  \"effect/ai/AiError/AuthenticationError\"\n)({\n  _tag: Schema.tag(\"AuthenticationError\"),\n  kind: Schema.Literals([\"InvalidKey\", \"ExpiredKey\", \"MissingKey\", \"InsufficientPermissions\", \"Unknown\"]),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false\n  }\n\n  override get message(): string {\n    const suggestions: Record<string, string> = {\n      InvalidKey: \"Verify your API key is correct\",\n      ExpiredKey: \"Your API key has expired. Generate a new one\",\n      MissingKey: \"No API key provided. Set the appropriate environment variable\",\n      InsufficientPermissions: \"Your API key lacks required permissions\",\n      Unknown: \"Authentication failed. Check your credentials\"\n    }\n    return `${this.kind}: ${suggestions[this.kind]}`\n  }\n}\n```\n\n#### ContentPolicyError\n\n```typescript\nexport class ContentPolicyError extends Schema.ErrorClass<ContentPolicyError>(\n  \"effect/ai/AiError/ContentPolicyError\"\n)({\n  _tag: Schema.tag(\"ContentPolicyError\"),\n  violationType: Schema.optional(Schema.String), // \"hate\" | \"violence\" | etc.\n  flaggedInput: Schema.optional(Schema.Boolean), // true if input was flagged\n  flaggedOutput: Schema.optional(Schema.Boolean), // true if output was flagged\n  flaggedContent: Schema.optional(Schema.String), // actual content that was flagged\n  categories: Schema.optional(Schema.Array(Schema.String)),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false\n  }\n\n  override get message(): string {\n    let msg = `Content policy violation`\n    if (this.violationType) msg += `: ${this.violationType}`\n    if (this.flaggedInput) msg += ` in input`\n    if (this.flaggedOutput) msg += ` in output`\n    return msg\n  }\n}\n```\n\n#### ModelUnavailableError\n\n```typescript\nexport class ModelUnavailableError extends Schema.ErrorClass<ModelUnavailableError>(\n  \"effect/ai/AiError/ModelUnavailableError\"\n)({\n  _tag: Schema.tag(\"ModelUnavailableError\"),\n  model: Schema.String,\n  kind: Schema.Literals([\"NotFound\", \"Deprecated\", \"Overloaded\", \"Maintenance\", \"Unknown\"]),\n  alternativeModels: Schema.optional(Schema.Array(Schema.String)),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    // Retryable only for temporary conditions\n    return this.kind === \"Overloaded\" || this.kind === \"Maintenance\"\n  }\n\n  override get message(): string {\n    let msg = `Model '${this.model}' unavailable: ${this.kind}`\n    if (this.alternativeModels && this.alternativeModels.length > 0) {\n      msg += `. Try: ${this.alternativeModels.join(\", \")}`\n    }\n    return msg\n  }\n}\n```\n\n#### ContextLengthError\n\n```typescript\nexport class ContextLengthError extends Schema.ErrorClass<ContextLengthError>(\n  \"effect/ai/AiError/ContextLengthError\"\n)({\n  _tag: Schema.tag(\"ContextLengthError\"),\n  maxTokens: Schema.optional(Schema.Number),\n  requestedTokens: Schema.optional(Schema.Number),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false // Requires reducing input, not just retrying\n  }\n\n  override get message(): string {\n    let msg = `Context length exceeded`\n    if (this.requestedTokens && this.maxTokens) {\n      msg += `: requested ${this.requestedTokens} tokens, max ${this.maxTokens}`\n    }\n    return `${msg}. Reduce input size or use a model with larger context window.`\n  }\n}\n```\n\n#### InvalidRequestError\n\nReplaces `MalformedInput` with clearer naming.\n\n```typescript\nexport class InvalidRequestError extends Schema.ErrorClass<InvalidRequestError>(\n  \"effect/ai/AiError/InvalidRequestError\"\n)({\n  _tag: Schema.tag(\"InvalidRequestError\"),\n  parameter: Schema.optional(Schema.String),\n  constraint: Schema.optional(Schema.String),\n  description: Schema.optional(Schema.String),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false // Invalid requests need to be fixed, not retried\n  }\n\n  override get message(): string {\n    let msg = `Invalid request`\n    if (this.parameter) msg += `: parameter '${this.parameter}'`\n    if (this.constraint) msg += ` ${this.constraint}`\n    if (this.description) msg += `. ${this.description}`\n    return msg\n  }\n}\n```\n\n#### ProviderInternalError\n\n```typescript\nexport class ProviderInternalError extends Schema.ErrorClass<ProviderInternalError>(\n  \"effect/ai/AiError/ProviderInternalError\"\n)({\n  _tag: Schema.tag(\"ProviderInternalError\"),\n  retryAfter: Schema.optional(Schema.Duration),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // Provider errors are typically transient\n  }\n\n  override get message(): string {\n    let msg = `Provider internal error`\n    if (this.provider?.name) msg = `${this.provider.name} internal error`\n    if (this.retryAfter) msg += `. Retry after ${Duration.format(this.retryAfter)}`\n    return `${msg}. This is likely temporary.`\n  }\n}\n```\n\n#### TimeoutError\n\n```typescript\nexport class TimeoutError extends Schema.ErrorClass<TimeoutError>(\n  \"effect/ai/AiError/TimeoutError\"\n)({\n  _tag: Schema.tag(\"TimeoutError\"),\n  phase: Schema.Literals([\"Connection\", \"Request\", \"Response\"]),\n  duration: Schema.optional(Schema.Duration),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // Timeouts are typically transient\n  }\n\n  override get message(): string {\n    let msg = `${this.phase} timeout`\n    if (this.duration) msg += ` after ${Duration.format(this.duration)}`\n    return msg\n  }\n}\n```\n\n#### NetworkError\n\n```typescript\nexport class NetworkError extends Schema.ErrorClass<NetworkError>(\n  \"effect/ai/AiError/NetworkError\"\n)({\n  _tag: Schema.tag(\"NetworkError\"),\n  kind: Schema.Literals([\"ConnectionRefused\", \"DnsLookupFailed\", \"TlsError\", \"Unknown\"]),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // Network errors are typically transient\n  }\n\n  override get message(): string {\n    const suggestions: Record<string, string> = {\n      ConnectionRefused: \"Check network connectivity and firewall settings\",\n      DnsLookupFailed: \"Verify the API endpoint hostname is correct\",\n      TlsError: \"TLS/SSL handshake failed. Check certificate validity\",\n      Unknown: \"Network error occurred. Check your connection\"\n    }\n    return `${this.kind}: ${suggestions[this.kind]}`\n  }\n}\n```\n\n#### OutputParseError\n\n```typescript\nexport class OutputParseError extends Schema.ErrorClass<OutputParseError>(\n  \"effect/ai/AiError/OutputParseError\"\n)({\n  _tag: Schema.tag(\"OutputParseError\"),\n  rawOutput: Schema.optional(Schema.String),\n  expectedSchema: Schema.optional(Schema.String),\n  provider: Schema.optional(ProviderMetadata),\n  usage: Schema.optional(UsageInfo),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // LLM outputs are non-deterministic, retry often works\n  }\n\n  static fromSchemaError(params: {\n    readonly rawOutput?: string\n    readonly error: Schema.SchemaError\n  }): OutputParseError {\n    return new OutputParseError({\n      rawOutput: params.rawOutput,\n      cause: params.error\n    })\n  }\n\n  override get message(): string {\n    return `Failed to parse LLM output into expected schema`\n  }\n}\n```\n\n#### UnknownError\n\n```typescript\nexport class UnknownError extends Schema.ErrorClass<UnknownError>(\n  \"effect/ai/AiError/UnknownError\"\n)({\n  _tag: Schema.tag(\"UnknownError\"),\n  description: Schema.optional(Schema.String),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false // Unknown errors are not safe to retry by default\n  }\n\n  override get message(): string {\n    return this.description ?? `Unknown error`\n  }\n}\n```\n\n### Supporting Schemas\n\n```typescript\nexport const ProviderMetadata = Schema.Struct({\n  name: Schema.String,\n  errorCode: Schema.optional(Schema.String),\n  errorType: Schema.optional(Schema.String),\n  requestId: Schema.optional(Schema.String),\n  raw: Schema.optional(Schema.Unknown)\n}).annotate({ identifier: \"ProviderMetadata\" })\n\nexport const HttpRequestDetails = Schema.Struct({\n  method: Schema.Literals([\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\"]),\n  url: Schema.String,\n  urlParams: Schema.Array(Schema.Tuple([Schema.String, Schema.String])),\n  hash: Schema.optional(Schema.String),\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpRequestDetails\" })\n\nexport const HttpResponseDetails = Schema.Struct({\n  status: Schema.Number,\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpResponseDetails\" })\n\nexport const HttpContext = Schema.Struct({\n  request: HttpRequestDetails,\n  response: Schema.optional(HttpResponseDetails),\n  body: Schema.optional(Schema.String)\n}).annotate({ identifier: \"HttpContext\" })\n\nexport const UsageInfo = Schema.Struct({\n  promptTokens: Schema.optional(Schema.Number),\n  completionTokens: Schema.optional(Schema.Number),\n  totalTokens: Schema.optional(Schema.Number)\n}).annotate({ identifier: \"UsageInfo\" })\n```\n\n### Reason Union Type\n\n```typescript\nexport type AiErrorReason =\n  | RateLimitError\n  | QuotaExhaustedError\n  | AuthenticationError\n  | ContentPolicyError\n  | ModelUnavailableError\n  | ContextLengthError\n  | InvalidRequestError\n  | ProviderInternalError\n  | TimeoutError\n  | NetworkError\n  | OutputParseError\n  | UnknownError\n\nexport const AiErrorReason: Schema.Union<[\n  typeof RateLimitError,\n  typeof QuotaExhaustedError,\n  typeof AuthenticationError,\n  typeof ContentPolicyError,\n  typeof ModelUnavailableError,\n  typeof ContextLengthError,\n  typeof InvalidRequestError,\n  typeof ProviderInternalError,\n  typeof TimeoutError,\n  typeof NetworkError,\n  typeof OutputParseError,\n  typeof UnknownError\n]> = Schema.Union([\n  RateLimitError,\n  QuotaExhaustedError,\n  AuthenticationError,\n  ContentPolicyError,\n  ModelUnavailableError,\n  ContextLengthError,\n  InvalidRequestError,\n  ProviderInternalError,\n  TimeoutError,\n  NetworkError,\n  OutputParseError,\n  UnknownError\n])\n```\n\n### Utility Functions (Core Module)\n\n```typescript\n/**\n * Creates an AiError with the given reason.\n */\nexport const make = (params: {\n  readonly module: string\n  readonly method: string\n  readonly reason: AiErrorReason\n}): AiError => new AiError(params)\n\n/**\n * Base HTTP status code to reason mapping.\n * Provider packages can extend this for provider-specific codes.\n */\nexport const reasonFromHttpStatus = (params: {\n  readonly status: number\n  readonly body?: unknown\n  readonly http?: typeof HttpContext.Type\n  readonly provider?: typeof ProviderMetadata.Type\n}): AiErrorReason => {\n  const { status, body, http, provider } = params\n  switch (status) {\n    case 400:\n      return new InvalidRequestError({ http, provider, cause: body })\n    case 401:\n      return new AuthenticationError({ kind: \"InvalidKey\", http, provider, cause: body })\n    case 403:\n      return new AuthenticationError({ kind: \"InsufficientPermissions\", http, provider, cause: body })\n    case 408:\n      return new TimeoutError({ phase: \"Request\", http, provider, cause: body })\n    case 429:\n      return new RateLimitError({ http, provider, cause: body })\n    default:\n      if (status >= 500) {\n        return new ProviderInternalError({ http, provider, cause: body })\n      }\n      return new UnknownError({ http, provider, cause: body })\n  }\n}\n```\n\n## Implementation Phases\n\n### Phase 1: Supporting Schemas\n\n**Goal**: Define foundational schemas for metadata and context.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n- [ ] **1.2** Add `UsageInfo` schema with token count fields\n- [ ] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n- [ ] **1.4** Keep existing `HttpResponseDetails` schema\n- [ ] **1.5** Add `HttpContext` schema combining request/response/body\n- [ ] **1.6** Run `pnpm lint-fix`\n- [ ] **1.7** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 2: Reason Classes (Part 1)\n\n**Goal**: Implement first batch of semantic reason types.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **2.1** Create `RateLimitError` with `isRetryable` getter (returns `true`), `retryAfter: Duration`, `limit`, `remaining`, `resetAt`\n- [ ] **2.2** Create `QuotaExhaustedError` with `isRetryable` getter (returns `false`), `quotaType`, `resetAt`\n- [ ] **2.3** Create `AuthenticationError` with `isRetryable` getter (returns `false`), `kind` discriminant\n- [ ] **2.4** Create `ContentPolicyError` with `isRetryable` getter (returns `false`), `violationType`, `flaggedInput`, `flaggedOutput`, `flaggedContent`, `categories`\n- [ ] **2.5** Create `ModelUnavailableError` with `isRetryable` getter (computed from `kind`), `model`, `kind`, `alternativeModels`\n- [ ] **2.6** Create `ContextLengthError` with `isRetryable` getter (returns `false`), `maxTokens`, `requestedTokens`\n- [ ] **2.7** Run `pnpm lint-fix`\n- [ ] **2.8** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 3: Reason Classes (Part 2)\n\n**Goal**: Implement remaining reason types.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **3.1** Create `InvalidRequestError` with `isRetryable` getter (returns `false`), `parameter`, `constraint`, `description`\n- [ ] **3.2** Create `ProviderInternalError` with `isRetryable` getter (returns `true`), `retryAfter: Duration`\n- [ ] **3.3** Create `TimeoutError` with `isRetryable` getter (returns `true`), `phase` discriminant, `duration: Duration`\n- [ ] **3.4** Create `NetworkError` with `isRetryable` getter (returns `true`), `kind` discriminant\n- [ ] **3.5** Create `OutputParseError` with `isRetryable` getter (returns `true`), `rawOutput`, `expectedSchema`, `fromSchemaError` static method\n- [ ] **3.6** Create `UnknownError` with `isRetryable` getter (returns `false`), `description`\n- [ ] **3.7** Run `pnpm lint-fix`\n- [ ] **3.8** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 4: AiErrorReason Union & Top-Level AiError\n\n**Goal**: Create reason union and top-level AiError wrapper.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **4.1** Create `AiErrorReason` type union of all reason types\n- [ ] **4.2** Create `AiErrorReason` schema union\n- [ ] **4.3** Create top-level `AiError` class with `module`, `method`, `reason: AiErrorReason`, `isRetryable` getter, `retryAfter` getter\n- [ ] **4.4** Implement `make` constructor function\n- [ ] **4.5** Implement `reasonFromHttpStatus` utility function\n- [ ] **4.6** Update `isAiError` type guard\n- [ ] **4.7** Run `pnpm lint-fix`\n- [ ] **4.8** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 5: Remove Deprecated Types & Update Consumers\n\n**Goal**: Remove old error types and update consumers to use new design.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n- `packages/effect/src/unstable/ai/LanguageModel.ts`\n- `packages/effect/src/unstable/ai/Toolkit.ts`\n\n**Tasks**:\n\n- [ ] **5.1** Remove `HttpRequestError` class\n- [ ] **5.2** Remove `HttpResponseError` class\n- [ ] **5.3** Remove `MalformedInput` class (replaced by `InvalidRequestError`)\n- [ ] **5.4** Remove `MalformedOutput` class (replaced by `OutputParseError`)\n- [ ] **5.5** Remove old `UnknownError` class\n- [ ] **5.6** Update `LanguageModel.ts` to use new `AiError` with `reason`\n- [ ] **5.7** Update `Toolkit.ts` to use new `AiError` with `reason`\n- [ ] **5.8** Update `isAiError` checks throughout codebase\n- [ ] **5.9** Run `pnpm lint-fix`\n- [ ] **5.10** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 6: Tests\n\n**Goal**: Comprehensive test coverage for all error types.\n\n**Files to create/modify**:\n\n- `packages/effect/test/unstable/ai/AiError.test.ts`\n\n**Tasks**:\n\n- [ ] **6.1** Test `AiError` construction with each reason type\n- [ ] **6.2** Test message generation for `AiError` and each reason\n- [ ] **6.3** Test `isRetryable` getter returns correct value for each reason type\n- [ ] **6.4** Test `AiError.isRetryable` delegates to reason's `isRetryable`\n- [ ] **6.5** Test `AiError.retryAfter` delegates to reason's `retryAfter` when present\n- [ ] **6.6** Test `Effect.catchReason(\"AiError\", \"<reason>\", ...)` for all reasons\n- [ ] **6.7** Test `Effect.catchReasons(\"AiError\", {...})` with multiple handlers\n- [ ] **6.8** Test `Effect.unwrapReason(\"AiError\")` promotes reason to error channel\n- [ ] **6.9** Test `reasonFromHttpStatus` mapping\n- [ ] **6.10** Test `OutputParseError.fromSchemaError` static method\n- [ ] **6.11** Test `isAiError` type guard\n- [ ] **6.12** Test schema encoding/decoding roundtrip for all types\n- [ ] **6.13** Run `pnpm test AiError`\n\n**Verification**: All tests pass\n\n### Phase 7: Documentation & JSDoc\n\n**Goal**: Comprehensive documentation with examples.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **7.1** Add module-level JSDoc with overview, `reason` pattern usage, and examples\n- [ ] **7.2** Add JSDoc to `AiError` class with `@example` showing `catchReason` usage\n- [ ] **7.3** Add JSDoc to each reason class with `@example`, `@since`, `@category`\n- [ ] **7.4** Add JSDoc to supporting schemas\n- [ ] **7.5** Add JSDoc to utility functions\n- [ ] **7.6** Run `pnpm docgen` to verify examples compile\n- [ ] **7.7** Run `pnpm lint-fix`\n\n**Verification**: `pnpm docgen` passes\n\n## Testing Requirements\n\n### Unit Tests\n\n- Construction of `AiError` with each reason type\n- `isRetryable` getter returns correct value for each reason type\n- `AiError.isRetryable` delegates to reason\n- `AiError.retryAfter` delegates to reason when present\n- Message generation for `AiError` (delegates to reason)\n- Message generation for each reason type\n- Type guard `isAiError`\n\n### Integration Tests\n\n- `reasonFromHttpStatus` mapping for:\n  - 400 -> `InvalidRequestError`\n  - 401 -> `AuthenticationError` (InvalidKey)\n  - 403 -> `AuthenticationError` (InsufficientPermissions)\n  - 408 -> `TimeoutError`\n  - 429 -> `RateLimitError`\n  - 5xx -> `ProviderInternalError`\n- Schema round-trip encoding/decoding for all types\n\n### Error Handling Pattern Tests\n\n- `Effect.catchReason(\"AiError\", \"RateLimitError\", handler)` works\n- `Effect.catchReasons(\"AiError\", { ... })` handles multiple reasons\n- `Effect.unwrapReason(\"AiError\")` extracts reason to error channel\n- Effect error channel typing is correct with `reason` pattern\n\n## Verification Checklist\n\n- [ ] `pnpm lint-fix` passes\n- [ ] `pnpm check` passes\n- [ ] `pnpm test AiError` passes\n- [ ] `pnpm docgen` passes\n- [ ] All errors use `Schema.ErrorClass` with `_tag` via `Schema.tag`\n- [ ] `AiError` has `module`, `method`, `reason` fields\n- [ ] `reason` field is union of all reason types\n- [ ] `Effect.catchReason` / `Effect.catchReasons` / `Effect.unwrapReason` work correctly\n- [ ] `retryAfter` uses `Schema.Duration`\n- [ ] `ContentPolicyError` includes `flaggedContent` field\n- [ ] No streaming-specific error types (use `TimeoutError`, `NetworkError`, etc.)\n- [ ] `MalformedInput` replaced by `InvalidRequestError`\n- [ ] Provider-specific mapping documented as responsibility of provider packages\n- [ ] All reason types have `isRetryable` getter\n- [ ] `AiError` has `isRetryable` and `retryAfter` getters that delegate to reason\n- [ ] All reason types have JSDoc with examples\n","after":"# AI Error Domain Model\n\n**Status: DRAFT**\n\n## Overview\n\nReplace the current `AiError` design with a comprehensive, provider-agnostic domain model for errors originating from large language model providers. The new design uses the `reason` pattern (see `Effect.catchReason`) where `AiError` is a top-level wrapper error containing `module`, `method`, and a `reason` field that holds the semantic error.\n\n## Problem Statement / Motivation\n\n### Current Limitations\n\n1. **Transport-centric errors**: Current errors (`HttpRequestError`, `HttpResponseError`) focus on HTTP mechanics, not AI-specific failure modes\n2. **Missing semantic categories**: No distinction between rate limiting, quota exhaustion, content policy violations, model availability, etc.\n3. **Poor retry guidance**: Errors don't indicate whether retrying is appropriate or provide backoff hints\n4. **Limited provider context**: No structured way to capture provider-specific error codes or metadata\n5. **No cost/usage context**: Errors don't capture token usage or cost information when available\n6. **Weak recoverability signals**: Callers can't easily determine if an error is transient vs permanent\n7. **Bad naming**: `MalformedInput` is unclear and doesn't convey semantic meaning\n\n### Goals\n\n- **Semantic error categories** that map to LLM-specific failure modes\n- **Provider-agnostic** design that works across OpenAI, Anthropic, Google, etc.\n- **Rich context** including retry hints, provider error codes, usage data\n- **Recoverability classification** (transient vs permanent)\n- **Actionable error messages** with specific remediation guidance\n- **Leverage `reason` pattern** for ergonomic error handling via `Effect.catchReason`\n\n## Design Decisions\n\n### 1. Schema.ErrorClass with `_tag` via Schema.tag\n\nAll errors use `Schema.ErrorClass` with `_tag` defined via `Schema.tag(\"...\")`:\n\n```typescript\nexport class RateLimitError extends Schema.ErrorClass<RateLimitError>(\n  \"effect/ai/AiError/RateLimitError\"\n)({\n  _tag: Schema.tag(\"RateLimitError\")\n  // ... fields\n}) {}\n```\n\n### 2. `reason` Pattern with Top-Level AiError\n\nUse the `reason` pattern recently introduced in Effect (see `Effect.catchReason`, `Effect.unwrapReason`). `AiError` is the top-level error with `module`, `method`, and `reason`:\n\n```typescript\nclass AiError extends Schema.ErrorClass<AiError>(\"effect/ai/AiError\")({\n  _tag: Schema.tag(\"AiError\"),\n  module: Schema.String,\n  method: Schema.String,\n  reason: AiErrorReason // Union of all semantic error types\n}) {}\n```\n\nThis enables:\n\n```typescript\n// Handle specific reason types\nprogram.pipe(\n  Effect.catchReason(\"AiError\", \"RateLimitError\", (reason) => Effect.succeed(`Retry after ${reason.retryAfter}`))\n)\n\n// Handle multiple reasons\nprogram.pipe(\n  Effect.catchReasons(\"AiError\", {\n    RateLimitError: (r) => Effect.succeed(`Retry after ${r.retryAfter}`),\n    QuotaExhaustedError: (r) => Effect.fail(new BillingError())\n  })\n)\n\n// Unwrap reason to error channel\nprogram.pipe(Effect.unwrapReason(\"AiError\"))\n// Effect<A, AiError> -> Effect<A, RateLimitError | QuotaExhaustedError | ...>\n```\n\n### 3. Provider-Specific Mapping in Provider Packages\n\nProvider-specific error mapping (e.g., OpenAI error codes -> semantic reasons) lives in provider packages, not in the core `AiError` module. The core module provides:\n\n- Semantic reason types\n- Base `AiError` wrapper\n- Generic HTTP -> reason mapping utilities\n\nProvider packages implement:\n\n- Provider-specific error code mapping\n- Custom reason construction from provider responses\n\n### 4. Semantic Error Categories\n\nMap provider errors to semantic categories:\n\n- `RateLimitError` - Request throttled (429s, provider-specific limits)\n- `QuotaExhaustedError` - Account/billing limits reached\n- `AuthenticationError` - Invalid/expired credentials\n- `ContentPolicyError` - Input/output violated content policy\n- `ModelUnavailableError` - Model not available/deprecated\n- `ContextLengthError` - Token limit exceeded\n- `InvalidRequestError` - Malformed request parameters (replaces `MalformedInput`)\n- `ProviderInternalError` - Provider-side failures (5xx)\n- `TimeoutError` - Request timeout (no streaming-specific types)\n- `NetworkError` - Transport-level failures\n- `OutputParseError` - LLM output parsing failures\n- `UnknownError` - Catch-all\n\n### 5. Recoverability Classification\n\nEach reason has an `isRetryable` getter that computes retryability based on the error state:\n\n```typescript\nget isRetryable(): boolean {\n  return true  // or computed based on error properties\n}\nreadonly retryAfter?: Duration  // Effect Duration type, when retry is recommended\n```\n\nThis approach:\n\n- Avoids redundant stored state\n- Allows retryability to be computed from other fields (e.g., `ModelUnavailableError` is retryable only if `kind` is `\"Overloaded\"` or `\"Maintenance\"`)\n- Keeps the schema simpler (no need for `Schema.Literal(true).withDefault()`)\n\n### 6. ContentPolicyError Includes Flagged Content\n\nWhen available, include the flagged content for debugging:\n\n```typescript\nflaggedContent: Schema.optional(Schema.String) // The actual content that was flagged\n```\n\n### 7. No Streaming-Specific Error Types\n\nStreaming errors map to existing reason types:\n\n- Stream timeout -> `TimeoutError`\n- Stream interrupted -> `NetworkError`\n- Partial response -> `OutputParseError` or `ProviderInternalError`\n\n## Technical Details\n\n### Top-Level AiError\n\n```typescript\nconst TypeId = \"~effect/unstable/ai/AiError\" as const\n\nexport class AiError extends Schema.ErrorClass<AiError>(\"effect/ai/AiError\")({\n  _tag: Schema.tag(\"AiError\"),\n  module: Schema.String,\n  method: Schema.String,\n  reason: AiErrorReason\n}) {\n  readonly [TypeId] = TypeId\n\n  /**\n   * Delegates to the underlying reason's isRetryable getter.\n   */\n  get isRetryable(): boolean {\n    return this.reason.isRetryable\n  }\n\n  /**\n   * Delegates to the underlying reason's retryAfter if present.\n   */\n  get retryAfter(): Duration | undefined {\n    return \"retryAfter\" in this.reason ? this.reason.retryAfter : undefined\n  }\n\n  override get message(): string {\n    return `${this.module}.${this.method}: ${this.reason.message}`\n  }\n}\n\nexport const isAiError = (u: unknown): u is AiError => Predicate.hasProperty(u, TypeId)\n```\n\n### Reason Type Definitions\n\n#### RateLimitError\n\n```typescript\nexport class RateLimitError extends Schema.ErrorClass<RateLimitError>(\n  \"effect/ai/AiError/RateLimitError\"\n)({\n  _tag: Schema.tag(\"RateLimitError\"),\n  retryAfter: Schema.optional(Schema.Duration),\n  limit: Schema.optional(Schema.String), // \"requests\" | \"tokens\" | etc.\n  remaining: Schema.optional(Schema.Number),\n  resetAt: Schema.optional(Schema.DateTimeUtc),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true\n  }\n\n  override get message(): string {\n    let msg = `Rate limit exceeded`\n    if (this.limit) msg += ` (${this.limit})`\n    if (this.retryAfter) msg += `. Retry after ${Duration.format(this.retryAfter)}`\n    return msg\n  }\n}\n```\n\n#### QuotaExhaustedError\n\n```typescript\nexport class QuotaExhaustedError extends Schema.ErrorClass<QuotaExhaustedError>(\n  \"effect/ai/AiError/QuotaExhaustedError\"\n)({\n  _tag: Schema.tag(\"QuotaExhaustedError\"),\n  quotaType: Schema.optional(Schema.String), // \"tokens\" | \"requests\" | \"spend\"\n  resetAt: Schema.optional(Schema.DateTimeUtc),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false\n  }\n\n  override get message(): string {\n    let msg = `Quota exhausted`\n    if (this.quotaType) msg += ` (${this.quotaType})`\n    if (this.resetAt) msg += `. Resets at ${this.resetAt}`\n    return `${msg}. Check your account billing and usage limits.`\n  }\n}\n```\n\n#### AuthenticationError\n\n```typescript\nexport class AuthenticationError extends Schema.ErrorClass<AuthenticationError>(\n  \"effect/ai/AiError/AuthenticationError\"\n)({\n  _tag: Schema.tag(\"AuthenticationError\"),\n  kind: Schema.Literals([\"InvalidKey\", \"ExpiredKey\", \"MissingKey\", \"InsufficientPermissions\", \"Unknown\"]),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false\n  }\n\n  override get message(): string {\n    const suggestions: Record<string, string> = {\n      InvalidKey: \"Verify your API key is correct\",\n      ExpiredKey: \"Your API key has expired. Generate a new one\",\n      MissingKey: \"No API key provided. Set the appropriate environment variable\",\n      InsufficientPermissions: \"Your API key lacks required permissions\",\n      Unknown: \"Authentication failed. Check your credentials\"\n    }\n    return `${this.kind}: ${suggestions[this.kind]}`\n  }\n}\n```\n\n#### ContentPolicyError\n\n```typescript\nexport class ContentPolicyError extends Schema.ErrorClass<ContentPolicyError>(\n  \"effect/ai/AiError/ContentPolicyError\"\n)({\n  _tag: Schema.tag(\"ContentPolicyError\"),\n  violationType: Schema.optional(Schema.String), // \"hate\" | \"violence\" | etc.\n  flaggedInput: Schema.optional(Schema.Boolean), // true if input was flagged\n  flaggedOutput: Schema.optional(Schema.Boolean), // true if output was flagged\n  flaggedContent: Schema.optional(Schema.String), // actual content that was flagged\n  categories: Schema.optional(Schema.Array(Schema.String)),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false\n  }\n\n  override get message(): string {\n    let msg = `Content policy violation`\n    if (this.violationType) msg += `: ${this.violationType}`\n    if (this.flaggedInput) msg += ` in input`\n    if (this.flaggedOutput) msg += ` in output`\n    return msg\n  }\n}\n```\n\n#### ModelUnavailableError\n\n```typescript\nexport class ModelUnavailableError extends Schema.ErrorClass<ModelUnavailableError>(\n  \"effect/ai/AiError/ModelUnavailableError\"\n)({\n  _tag: Schema.tag(\"ModelUnavailableError\"),\n  model: Schema.String,\n  kind: Schema.Literals([\"NotFound\", \"Deprecated\", \"Overloaded\", \"Maintenance\", \"Unknown\"]),\n  alternativeModels: Schema.optional(Schema.Array(Schema.String)),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    // Retryable only for temporary conditions\n    return this.kind === \"Overloaded\" || this.kind === \"Maintenance\"\n  }\n\n  override get message(): string {\n    let msg = `Model '${this.model}' unavailable: ${this.kind}`\n    if (this.alternativeModels && this.alternativeModels.length > 0) {\n      msg += `. Try: ${this.alternativeModels.join(\", \")}`\n    }\n    return msg\n  }\n}\n```\n\n#### ContextLengthError\n\n```typescript\nexport class ContextLengthError extends Schema.ErrorClass<ContextLengthError>(\n  \"effect/ai/AiError/ContextLengthError\"\n)({\n  _tag: Schema.tag(\"ContextLengthError\"),\n  maxTokens: Schema.optional(Schema.Number),\n  requestedTokens: Schema.optional(Schema.Number),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false // Requires reducing input, not just retrying\n  }\n\n  override get message(): string {\n    let msg = `Context length exceeded`\n    if (this.requestedTokens && this.maxTokens) {\n      msg += `: requested ${this.requestedTokens} tokens, max ${this.maxTokens}`\n    }\n    return `${msg}. Reduce input size or use a model with larger context window.`\n  }\n}\n```\n\n#### InvalidRequestError\n\nReplaces `MalformedInput` with clearer naming.\n\n```typescript\nexport class InvalidRequestError extends Schema.ErrorClass<InvalidRequestError>(\n  \"effect/ai/AiError/InvalidRequestError\"\n)({\n  _tag: Schema.tag(\"InvalidRequestError\"),\n  parameter: Schema.optional(Schema.String),\n  constraint: Schema.optional(Schema.String),\n  description: Schema.optional(Schema.String),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false // Invalid requests need to be fixed, not retried\n  }\n\n  override get message(): string {\n    let msg = `Invalid request`\n    if (this.parameter) msg += `: parameter '${this.parameter}'`\n    if (this.constraint) msg += ` ${this.constraint}`\n    if (this.description) msg += `. ${this.description}`\n    return msg\n  }\n}\n```\n\n#### ProviderInternalError\n\n```typescript\nexport class ProviderInternalError extends Schema.ErrorClass<ProviderInternalError>(\n  \"effect/ai/AiError/ProviderInternalError\"\n)({\n  _tag: Schema.tag(\"ProviderInternalError\"),\n  retryAfter: Schema.optional(Schema.Duration),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // Provider errors are typically transient\n  }\n\n  override get message(): string {\n    let msg = `Provider internal error`\n    if (this.provider?.name) msg = `${this.provider.name} internal error`\n    if (this.retryAfter) msg += `. Retry after ${Duration.format(this.retryAfter)}`\n    return `${msg}. This is likely temporary.`\n  }\n}\n```\n\n#### TimeoutError\n\n```typescript\nexport class TimeoutError extends Schema.ErrorClass<TimeoutError>(\n  \"effect/ai/AiError/TimeoutError\"\n)({\n  _tag: Schema.tag(\"TimeoutError\"),\n  phase: Schema.Literals([\"Connection\", \"Request\", \"Response\"]),\n  duration: Schema.optional(Schema.Duration),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // Timeouts are typically transient\n  }\n\n  override get message(): string {\n    let msg = `${this.phase} timeout`\n    if (this.duration) msg += ` after ${Duration.format(this.duration)}`\n    return msg\n  }\n}\n```\n\n#### NetworkError\n\n```typescript\nexport class NetworkError extends Schema.ErrorClass<NetworkError>(\n  \"effect/ai/AiError/NetworkError\"\n)({\n  _tag: Schema.tag(\"NetworkError\"),\n  kind: Schema.Literals([\"ConnectionRefused\", \"DnsLookupFailed\", \"TlsError\", \"Unknown\"]),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // Network errors are typically transient\n  }\n\n  override get message(): string {\n    const suggestions: Record<string, string> = {\n      ConnectionRefused: \"Check network connectivity and firewall settings\",\n      DnsLookupFailed: \"Verify the API endpoint hostname is correct\",\n      TlsError: \"TLS/SSL handshake failed. Check certificate validity\",\n      Unknown: \"Network error occurred. Check your connection\"\n    }\n    return `${this.kind}: ${suggestions[this.kind]}`\n  }\n}\n```\n\n#### OutputParseError\n\n```typescript\nexport class OutputParseError extends Schema.ErrorClass<OutputParseError>(\n  \"effect/ai/AiError/OutputParseError\"\n)({\n  _tag: Schema.tag(\"OutputParseError\"),\n  rawOutput: Schema.optional(Schema.String),\n  expectedSchema: Schema.optional(Schema.String),\n  provider: Schema.optional(ProviderMetadata),\n  usage: Schema.optional(UsageInfo),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return true // LLM outputs are non-deterministic, retry often works\n  }\n\n  static fromSchemaError(params: {\n    readonly rawOutput?: string\n    readonly error: Schema.SchemaError\n  }): OutputParseError {\n    return new OutputParseError({\n      rawOutput: params.rawOutput,\n      cause: params.error\n    })\n  }\n\n  override get message(): string {\n    return `Failed to parse LLM output into expected schema`\n  }\n}\n```\n\n#### UnknownError\n\n```typescript\nexport class UnknownError extends Schema.ErrorClass<UnknownError>(\n  \"effect/ai/AiError/UnknownError\"\n)({\n  _tag: Schema.tag(\"UnknownError\"),\n  description: Schema.optional(Schema.String),\n  provider: Schema.optional(ProviderMetadata),\n  http: Schema.optional(HttpContext),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  get isRetryable(): boolean {\n    return false // Unknown errors are not safe to retry by default\n  }\n\n  override get message(): string {\n    return this.description ?? `Unknown error`\n  }\n}\n```\n\n### Supporting Schemas\n\n```typescript\nexport const ProviderMetadata = Schema.Struct({\n  name: Schema.String,\n  errorCode: Schema.optional(Schema.String),\n  errorType: Schema.optional(Schema.String),\n  requestId: Schema.optional(Schema.String),\n  raw: Schema.optional(Schema.Unknown)\n}).annotate({ identifier: \"ProviderMetadata\" })\n\nexport const HttpRequestDetails = Schema.Struct({\n  method: Schema.Literals([\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\"]),\n  url: Schema.String,\n  urlParams: Schema.Array(Schema.Tuple([Schema.String, Schema.String])),\n  hash: Schema.optional(Schema.String),\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpRequestDetails\" })\n\nexport const HttpResponseDetails = Schema.Struct({\n  status: Schema.Number,\n  headers: Schema.Record(Schema.String, Schema.String)\n}).annotate({ identifier: \"HttpResponseDetails\" })\n\nexport const HttpContext = Schema.Struct({\n  request: HttpRequestDetails,\n  response: Schema.optional(HttpResponseDetails),\n  body: Schema.optional(Schema.String)\n}).annotate({ identifier: \"HttpContext\" })\n\nexport const UsageInfo = Schema.Struct({\n  promptTokens: Schema.optional(Schema.Number),\n  completionTokens: Schema.optional(Schema.Number),\n  totalTokens: Schema.optional(Schema.Number)\n}).annotate({ identifier: \"UsageInfo\" })\n```\n\n### Reason Union Type\n\n```typescript\nexport type AiErrorReason =\n  | RateLimitError\n  | QuotaExhaustedError\n  | AuthenticationError\n  | ContentPolicyError\n  | ModelUnavailableError\n  | ContextLengthError\n  | InvalidRequestError\n  | ProviderInternalError\n  | TimeoutError\n  | NetworkError\n  | OutputParseError\n  | UnknownError\n\nexport const AiErrorReason: Schema.Union<[\n  typeof RateLimitError,\n  typeof QuotaExhaustedError,\n  typeof AuthenticationError,\n  typeof ContentPolicyError,\n  typeof ModelUnavailableError,\n  typeof ContextLengthError,\n  typeof InvalidRequestError,\n  typeof ProviderInternalError,\n  typeof TimeoutError,\n  typeof NetworkError,\n  typeof OutputParseError,\n  typeof UnknownError\n]> = Schema.Union([\n  RateLimitError,\n  QuotaExhaustedError,\n  AuthenticationError,\n  ContentPolicyError,\n  ModelUnavailableError,\n  ContextLengthError,\n  InvalidRequestError,\n  ProviderInternalError,\n  TimeoutError,\n  NetworkError,\n  OutputParseError,\n  UnknownError\n])\n```\n\n### Utility Functions (Core Module)\n\n```typescript\n/**\n * Creates an AiError with the given reason.\n */\nexport const make = (params: {\n  readonly module: string\n  readonly method: string\n  readonly reason: AiErrorReason\n}): AiError => new AiError(params)\n\n/**\n * Base HTTP status code to reason mapping.\n * Provider packages can extend this for provider-specific codes.\n */\nexport const reasonFromHttpStatus = (params: {\n  readonly status: number\n  readonly body?: unknown\n  readonly http?: typeof HttpContext.Type\n  readonly provider?: typeof ProviderMetadata.Type\n}): AiErrorReason => {\n  const { status, body, http, provider } = params\n  switch (status) {\n    case 400:\n      return new InvalidRequestError({ http, provider, cause: body })\n    case 401:\n      return new AuthenticationError({ kind: \"InvalidKey\", http, provider, cause: body })\n    case 403:\n      return new AuthenticationError({ kind: \"InsufficientPermissions\", http, provider, cause: body })\n    case 408:\n      return new TimeoutError({ phase: \"Request\", http, provider, cause: body })\n    case 429:\n      return new RateLimitError({ http, provider, cause: body })\n    default:\n      if (status >= 500) {\n        return new ProviderInternalError({ http, provider, cause: body })\n      }\n      return new UnknownError({ http, provider, cause: body })\n  }\n}\n```\n\n## Implementation Phases\n\n### Phase 1: Supporting Schemas\n\n**Goal**: Define foundational schemas for metadata and context.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [x] **1.1** Add `ProviderMetadata` schema with `name`, `errorCode`, `errorType`, `requestId`, `raw` fields\n- [x] **1.2** Add `UsageInfo` schema with token count fields\n- [x] **1.3** Keep existing `HttpRequestDetails` schema (already well-defined)\n- [x] **1.4** Keep existing `HttpResponseDetails` schema\n- [x] **1.5** Add `HttpContext` schema combining request/response/body\n- [x] **1.6** Run `pnpm lint-fix`\n- [x] **1.7** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 2: Reason Classes (Part 1)\n\n**Goal**: Implement first batch of semantic reason types.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **2.1** Create `RateLimitError` with `isRetryable` getter (returns `true`), `retryAfter: Duration`, `limit`, `remaining`, `resetAt`\n- [ ] **2.2** Create `QuotaExhaustedError` with `isRetryable` getter (returns `false`), `quotaType`, `resetAt`\n- [ ] **2.3** Create `AuthenticationError` with `isRetryable` getter (returns `false`), `kind` discriminant\n- [ ] **2.4** Create `ContentPolicyError` with `isRetryable` getter (returns `false`), `violationType`, `flaggedInput`, `flaggedOutput`, `flaggedContent`, `categories`\n- [ ] **2.5** Create `ModelUnavailableError` with `isRetryable` getter (computed from `kind`), `model`, `kind`, `alternativeModels`\n- [ ] **2.6** Create `ContextLengthError` with `isRetryable` getter (returns `false`), `maxTokens`, `requestedTokens`\n- [ ] **2.7** Run `pnpm lint-fix`\n- [ ] **2.8** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 3: Reason Classes (Part 2)\n\n**Goal**: Implement remaining reason types.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **3.1** Create `InvalidRequestError` with `isRetryable` getter (returns `false`), `parameter`, `constraint`, `description`\n- [ ] **3.2** Create `ProviderInternalError` with `isRetryable` getter (returns `true`), `retryAfter: Duration`\n- [ ] **3.3** Create `TimeoutError` with `isRetryable` getter (returns `true`), `phase` discriminant, `duration: Duration`\n- [ ] **3.4** Create `NetworkError` with `isRetryable` getter (returns `true`), `kind` discriminant\n- [ ] **3.5** Create `OutputParseError` with `isRetryable` getter (returns `true`), `rawOutput`, `expectedSchema`, `fromSchemaError` static method\n- [ ] **3.6** Create `UnknownError` with `isRetryable` getter (returns `false`), `description`\n- [ ] **3.7** Run `pnpm lint-fix`\n- [ ] **3.8** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 4: AiErrorReason Union & Top-Level AiError\n\n**Goal**: Create reason union and top-level AiError wrapper.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **4.1** Create `AiErrorReason` type union of all reason types\n- [ ] **4.2** Create `AiErrorReason` schema union\n- [ ] **4.3** Create top-level `AiError` class with `module`, `method`, `reason: AiErrorReason`, `isRetryable` getter, `retryAfter` getter\n- [ ] **4.4** Implement `make` constructor function\n- [ ] **4.5** Implement `reasonFromHttpStatus` utility function\n- [ ] **4.6** Update `isAiError` type guard\n- [ ] **4.7** Run `pnpm lint-fix`\n- [ ] **4.8** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 5: Remove Deprecated Types & Update Consumers\n\n**Goal**: Remove old error types and update consumers to use new design.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n- `packages/effect/src/unstable/ai/LanguageModel.ts`\n- `packages/effect/src/unstable/ai/Toolkit.ts`\n\n**Tasks**:\n\n- [ ] **5.1** Remove `HttpRequestError` class\n- [ ] **5.2** Remove `HttpResponseError` class\n- [ ] **5.3** Remove `MalformedInput` class (replaced by `InvalidRequestError`)\n- [ ] **5.4** Remove `MalformedOutput` class (replaced by `OutputParseError`)\n- [ ] **5.5** Remove old `UnknownError` class\n- [ ] **5.6** Update `LanguageModel.ts` to use new `AiError` with `reason`\n- [ ] **5.7** Update `Toolkit.ts` to use new `AiError` with `reason`\n- [ ] **5.8** Update `isAiError` checks throughout codebase\n- [ ] **5.9** Run `pnpm lint-fix`\n- [ ] **5.10** Run `pnpm check`\n\n**Verification**: `pnpm check` passes\n\n### Phase 6: Tests\n\n**Goal**: Comprehensive test coverage for all error types.\n\n**Files to create/modify**:\n\n- `packages/effect/test/unstable/ai/AiError.test.ts`\n\n**Tasks**:\n\n- [ ] **6.1** Test `AiError` construction with each reason type\n- [ ] **6.2** Test message generation for `AiError` and each reason\n- [ ] **6.3** Test `isRetryable` getter returns correct value for each reason type\n- [ ] **6.4** Test `AiError.isRetryable` delegates to reason's `isRetryable`\n- [ ] **6.5** Test `AiError.retryAfter` delegates to reason's `retryAfter` when present\n- [ ] **6.6** Test `Effect.catchReason(\"AiError\", \"<reason>\", ...)` for all reasons\n- [ ] **6.7** Test `Effect.catchReasons(\"AiError\", {...})` with multiple handlers\n- [ ] **6.8** Test `Effect.unwrapReason(\"AiError\")` promotes reason to error channel\n- [ ] **6.9** Test `reasonFromHttpStatus` mapping\n- [ ] **6.10** Test `OutputParseError.fromSchemaError` static method\n- [ ] **6.11** Test `isAiError` type guard\n- [ ] **6.12** Test schema encoding/decoding roundtrip for all types\n- [ ] **6.13** Run `pnpm test AiError`\n\n**Verification**: All tests pass\n\n### Phase 7: Documentation & JSDoc\n\n**Goal**: Comprehensive documentation with examples.\n\n**Files to modify**:\n\n- `packages/effect/src/unstable/ai/AiError.ts`\n\n**Tasks**:\n\n- [ ] **7.1** Add module-level JSDoc with overview, `reason` pattern usage, and examples\n- [ ] **7.2** Add JSDoc to `AiError` class with `@example` showing `catchReason` usage\n- [ ] **7.3** Add JSDoc to each reason class with `@example`, `@since`, `@category`\n- [ ] **7.4** Add JSDoc to supporting schemas\n- [ ] **7.5** Add JSDoc to utility functions\n- [ ] **7.6** Run `pnpm docgen` to verify examples compile\n- [ ] **7.7** Run `pnpm lint-fix`\n\n**Verification**: `pnpm docgen` passes\n\n## Testing Requirements\n\n### Unit Tests\n\n- Construction of `AiError` with each reason type\n- `isRetryable` getter returns correct value for each reason type\n- `AiError.isRetryable` delegates to reason\n- `AiError.retryAfter` delegates to reason when present\n- Message generation for `AiError` (delegates to reason)\n- Message generation for each reason type\n- Type guard `isAiError`\n\n### Integration Tests\n\n- `reasonFromHttpStatus` mapping for:\n  - 400 -> `InvalidRequestError`\n  - 401 -> `AuthenticationError` (InvalidKey)\n  - 403 -> `AuthenticationError` (InsufficientPermissions)\n  - 408 -> `TimeoutError`\n  - 429 -> `RateLimitError`\n  - 5xx -> `ProviderInternalError`\n- Schema round-trip encoding/decoding for all types\n\n### Error Handling Pattern Tests\n\n- `Effect.catchReason(\"AiError\", \"RateLimitError\", handler)` works\n- `Effect.catchReasons(\"AiError\", { ... })` handles multiple reasons\n- `Effect.unwrapReason(\"AiError\")` extracts reason to error channel\n- Effect error channel typing is correct with `reason` pattern\n\n## Verification Checklist\n\n- [ ] `pnpm lint-fix` passes\n- [ ] `pnpm check` passes\n- [ ] `pnpm test AiError` passes\n- [ ] `pnpm docgen` passes\n- [ ] All errors use `Schema.ErrorClass` with `_tag` via `Schema.tag`\n- [ ] `AiError` has `module`, `method`, `reason` fields\n- [ ] `reason` field is union of all reason types\n- [ ] `Effect.catchReason` / `Effect.catchReasons` / `Effect.unwrapReason` work correctly\n- [ ] `retryAfter` uses `Schema.Duration`\n- [ ] `ContentPolicyError` includes `flaggedContent` field\n- [ ] No streaming-specific error types (use `TimeoutError`, `NetworkError`, etc.)\n- [ ] `MalformedInput` replaced by `InvalidRequestError`\n- [ ] Provider-specific mapping documented as responsibility of provider packages\n- [ ] All reason types have `isRetryable` getter\n- [ ] `AiError` has `isRetryable` and `retryAfter` getters that delegate to reason\n- [ ] All reason types have JSDoc with examples\n","additions":7,"deletions":7},"truncated":false},"time":{"start":1768774491952,"end":1768774491956}}}}
{"type":"step_finish","timestamp":1768774492003,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cdf35001brn0xT2D82jTGq","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cca17001bfzJ1ownZz4AlG","type":"step-finish","reason":"tool-calls","snapshot":"6fe32cce69dc209b142f2ca539f27cf9c6cc5d47","cost":0,"tokens":{"input":0,"output":472,"reasoning":0,"cache":{"read":47167,"write":613}}}}
{"type":"step_start","timestamp":1768774494458,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32ce8f9001PTAamMZilC7U0U","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cdfa1001UpLtECF7G2dpXH","type":"step-start","snapshot":"711086926b1afbd3cdfad0544f08f30975ee697d"}}
{"type":"tool_use","timestamp":1768774496745,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32ce8fa001UHNuiJx08yjRgT","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cdfa1001UpLtECF7G2dpXH","type":"tool","callID":"toolu_011QW1NKm51H25LkUJ6Vxbyu","tool":"todowrite","state":{"status":"completed","input":{"todos":[{"id":"1","content":"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)","status":"completed","priority":"high"},{"id":"2","content":"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)","status":"pending","priority":"high"},{"id":"3","content":"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)","status":"pending","priority":"high"},{"id":"4","content":"Phase 4: Create AiErrorReason union and top-level AiError wrapper","status":"pending","priority":"high"},{"id":"5","content":"Phase 5: Remove deprecated types and update consumers","status":"pending","priority":"high"},{"id":"6","content":"Phase 6: Write comprehensive tests","status":"pending","priority":"high"},{"id":"7","content":"Phase 7: Add JSDoc documentation","status":"pending","priority":"high"}]},"output":"[\n  {\n    \"id\": \"1\",\n    \"content\": \"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)\",\n    \"status\": \"completed\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"2\",\n    \"content\": \"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"3\",\n    \"content\": \"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"4\",\n    \"content\": \"Phase 4: Create AiErrorReason union and top-level AiError wrapper\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"5\",\n    \"content\": \"Phase 5: Remove deprecated types and update consumers\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"6\",\n    \"content\": \"Phase 6: Write comprehensive tests\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  },\n  {\n    \"id\": \"7\",\n    \"content\": \"Phase 7: Add JSDoc documentation\",\n    \"status\": \"pending\",\n    \"priority\": \"high\"\n  }\n]","title":"6 todos","metadata":{"todos":[{"id":"1","content":"Phase 1: Add supporting schemas (ProviderMetadata, UsageInfo, HttpContext)","status":"completed","priority":"high"},{"id":"2","content":"Phase 2: Create reason classes Part 1 (RateLimitError, QuotaExhaustedError, AuthenticationError, ContentPolicyError, ModelUnavailableError, ContextLengthError)","status":"pending","priority":"high"},{"id":"3","content":"Phase 3: Create reason classes Part 2 (InvalidRequestError, ProviderInternalError, TimeoutError, NetworkError, OutputParseError, new UnknownError)","status":"pending","priority":"high"},{"id":"4","content":"Phase 4: Create AiErrorReason union and top-level AiError wrapper","status":"pending","priority":"high"},{"id":"5","content":"Phase 5: Remove deprecated types and update consumers","status":"pending","priority":"high"},{"id":"6","content":"Phase 6: Write comprehensive tests","status":"pending","priority":"high"},{"id":"7","content":"Phase 7: Add JSDoc documentation","status":"pending","priority":"high"}],"truncated":false},"time":{"start":1768774496738,"end":1768774496745}}}}
{"type":"step_finish","timestamp":1768774496798,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cf1eb001PRcrbRW9l6wIHI","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cdfa1001UpLtECF7G2dpXH","type":"step-finish","reason":"tool-calls","snapshot":"35ca57ae4124f44794a66960135143cafe09825e","cost":0,"tokens":{"input":0,"output":376,"reasoning":0,"cache":{"read":47780,"write":487}}}}
{"type":"step_start","timestamp":1768774499316,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cfbf3001tiAeujozqgjaQe","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cf25a001qeItU3vGz5m203","type":"step-start","snapshot":"33bbfd596a6cb41051cbadbe5c638741cfcd7ed1"}}
{"type":"text","timestamp":1768774499663,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cfbf4001Z2B0qUg4POh6rG","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cf25a001qeItU3vGz5m203","type":"text","text":"TASK_COMPLETE: Add ProviderMetadata, UsageInfo, HttpContext supporting schemas","time":{"start":1768774499661,"end":1768774499661}}}
{"type":"step_finish","timestamp":1768774499725,"sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","part":{"id":"prt_bd32cfd5e0012zdxIEuep6Kc3v","sessionID":"ses_42cd439c7ffezvoqx0mHJ9FTS8","messageID":"msg_bd32cf25a001qeItU3vGz5m203","type":"step-finish","reason":"stop","snapshot":"98b5618befec44c43ccfa4e6091dc5330a2fdae6","cost":0,"tokens":{"input":0,"output":24,"reasoning":0,"cache":{"read":48267,"write":802}}}}
