// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`completions > bash 1`] = `
"function _forge_bash_completions() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur=\\"\${COMP_WORDS[COMP_CWORD]}\\"
    prev=\\"\${COMP_WORDS[COMP_CWORD-1]}\\"
    cmd=\\"\\"
    opts=\\"\\"
    for i in "\${COMP_WORDS[@]}"; do
        case "\${cmd},\${i}" in
            ,forge)
                cmd="__forge_forge_opts"
                ;;
            ,forge build)
                cmd="__forge_forge_build_opts"
                ;;
            ,forge deploy)
                cmd="__forge_forge_deploy_opts"
                ;;
            *)
                ;;
        esac
    done
    case \\"\${cmd}\\" in
        __forge_forge_opts)
            opts="-v --verbose --log-level build deploy"
            if [[ \${cur} == -* || \${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "-v --verbose --log-level build deploy" -- "\${cur}") )
                return 0
            fi
            case \\"\${prev}\\" in
                "--log-level") COMPREPLY=( "\${cur}" ); return 0 ;;
            *)
                COMPREPLY=()
                ;;
            esac
            COMPREPLY=( $(compgen -W "-v --verbose --log-level build deploy" -- "\${cur}") )
            return 0
            ;;
        __forge_forge_build_opts)
            opts="--out-dir --target"
            if [[ \${cur} == -* || \${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "--out-dir --target" -- "\${cur}") )
                return 0
            fi
            case \\"\${prev}\\" in
                "--out-dir") COMPREPLY=( $(compgen -d "\${cur}") ); return 0 ;;
                "--target") COMPREPLY=( "\${cur}" ); return 0 ;;
            *)
                COMPREPLY=()
                ;;
            esac
            COMPREPLY=( $(compgen -W "--out-dir --target" -- "\${cur}") )
            return 0
            ;;
        __forge_forge_deploy_opts)
            opts="--env --file"
            if [[ \${cur} == -* || \${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "--env --file" -- "\${cur}") )
                return 0
            fi
            case \\"\${prev}\\" in
                "--env") COMPREPLY=( "\${cur}" ); return 0 ;;
                "--file") COMPREPLY=( $(compgen -f "\${cur}") ); return 0 ;;
            *)
                COMPREPLY=()
                ;;
            esac
            COMPREPLY=( $(compgen -W "--env --file" -- "\${cur}") )
            return 0
            ;;
    esac
}
complete -F _forge_bash_completions -o nosort -o bashdefault -o default forge"
`;

exports[`completions > fish 1`] = `
"complete -c forge -n "__fish_use_subcommand" -f -a "build"
complete -c forge -n "__fish_use_subcommand" -f -a "deploy"
complete -c forge -n "__fish_use_subcommand" -l verbose -s v -f
complete -c forge -n "__fish_use_subcommand" -l log-level -r
complete -c forge -n "__fish_seen_subcommand_from build" -l out-dir -r -f -a "(__fish_complete_directories (commandline -ct))"
complete -c forge -n "__fish_seen_subcommand_from build" -l target -r
complete -c forge -n "__fish_seen_subcommand_from deploy" -l env -r
complete -c forge -n "__fish_seen_subcommand_from deploy" -l file -r -f -a "(__fish_complete_path (commandline -ct))""
`;

exports[`completions > zsh 1`] = `
"#compdef forge

function _forge_zsh_completions() {
  _forge_zsh_route
}

function _forge_zsh_route() {
  local -i i=2
  local w
  local ctx="forge"
  local handler="_forge_forge_handler"
  local -i shift_index=0

  # Walk through words to find the deepest subcommand,
  # skipping option values for the current context.
  while (( i <= $#words )); do
    w=\${words[i]}
    if [[ $w == -* ]]; then
      case "$ctx" in
    forge)
      case "$w" in
        "--log-level") ((i++));;
      esac
      ;;
    forge_build)
      case "$w" in
        "--out-dir"|"--target") ((i++));;
      esac
      ;;
    forge_deploy)
      case "$w" in
        "--env"|"--file") ((i++));;
      esac
      ;;
      esac
    else
      case "$ctx:$w" in
    "forge:build")
      ctx="forge_build"
      handler="_forge_forge_build_handler"
      shift_index=$i
      ;;
    "forge:deploy")
      ctx="forge_deploy"
      handler="_forge_forge_deploy_handler"
      shift_index=$i
      ;;
      esac
    fi
    (( i++ ))
  done

  # If we matched a subcommand, drop everything up to it so the child
  # handler sees only its own argv (avoids parent options confusing _arguments).
  if (( shift_index > 0 )); then
    (( CURRENT -= shift_index - 1 ))
    if (( CURRENT < 1 )); then CURRENT=1; fi
    shift $(( shift_index - 1 )) words
  fi

  # Call the most specific handler for the current context
  $handler
}

function _forge_forge_handler() {
  local ret=1
  local context state line
  typeset -A opt_args
  _arguments -C -s -S "--verbose[verbose]" "-v[verbose]" "--log-level=[log-level]:log_level:_message 'value'" "*::subcommand:->sub_forge"
  ret=$?
  case $state in
  sub_forge)
    local -a subcmds
    subcmds=(
      'build:build command'
      'deploy:deploy command'
    )
    _describe -t commands 'subcommand' subcmds && ret=0
    ;;
  esac
  return ret
}

function _forge_forge_build_handler() {
  local ret=1
  local context state line
  typeset -A opt_args
  _arguments -C -s -S "--out-dir=[out-dir]:out_dir:_path_files -/" "--target=[target]:target:_message 'value'"
  ret=$?
  case $state in
  esac
  return ret
}

function _forge_forge_deploy_handler() {
  local ret=1
  local context state line
  typeset -A opt_args
  _arguments -C -s -S "--env=[env]:env:_message 'value'" "--file=[file]:file:_files"
  ret=$?
  case $state in
  esac
  return ret
}


if [ "$funcstack[1]" = "_forge_zsh_completions" ]; then
  _forge_zsh_completions "$@"
else
  compdef _forge_zsh_completions forge
fi"
`;
