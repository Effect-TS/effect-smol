/**
 * @since 1.0.0
 */
import * as Effect from "effect/Effect"
import * as Base64 from "effect/encoding/Base64"
import { dual } from "effect/Function"
import * as Layer from "effect/Layer"
import * as Predicate from "effect/Predicate"
import * as ServiceMap from "effect/ServiceMap"
import type { Simplify } from "effect/Types"
import * as AiError from "effect/unstable/ai/AiError"
import * as LanguageModel from "effect/unstable/ai/LanguageModel"
import * as AiModel from "effect/unstable/ai/Model"
import type * as Prompt from "effect/unstable/ai/Prompt"
import type * as Tool from "effect/unstable/ai/Tool"
import { AnthropicClient } from "./AnthropicClient.ts"
import type * as Generated from "./Generated.ts"

/**
 * @since 1.0.0
 * @category models
 */
export type Model = typeof Generated.Model.Type

// =============================================================================
// Configuration
// =============================================================================

/**
 * Service definition for Anthropic language model configuration.
 *
 * @since 1.0.0
 * @category service
 */
export class Config extends ServiceMap.Service<
  Config,
  Simplify<
    & Partial<
      Omit<
        typeof Generated.CreateMessageParams.Encoded,
        "messages" | "tools" | "tool_choice" | "stream"
      >
    >
    & {
      /**
       * Disables Claude's ability to use multiple tools to respond to a query.
       */
      readonly disableParallelToolCalls?: boolean | undefined
    }
  >
>()("@effect/ai-anthropic/AnthropicLanguageModel/Config") {}

// =============================================================================
// Provider Options / Metadata
// =============================================================================

declare module "effect/unstable/ai/Prompt" {
  export interface SystemMessageOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface UserMessageOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface AssistantMessageOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface ToolMessageOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface TextPartOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface ReasoningPartOptions extends ProviderOptions {
    readonly anthropic?: {
      readonly info?: {
        readonly type: "thinking"
        /**
         * Thinking content as an encrypted string, which is used to verify
         * that thinking content was indeed generated by Anthropic's API.
         */
        readonly signature: typeof Generated.ResponseThinkingBlock.fields.thinking.Encoded
      } | {
        readonly type: "redacted_thinking"
        /**
         * Thinking content which was flagged by Anthropic's safety systems, and
         * was therefore encrypted.
         */
        readonly redactedData: typeof Generated.ResponseRedactedThinkingBlock.fields.data.Encoded
      } | null
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface FilePartOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
      /**
       * Whether or not citations should be enabled for the file part.
       */
      readonly citations?: typeof Generated.RequestCitationsConfig.Encoded | null
      /**
       * A custom title to provide to the document. If omitted, the file part's
       * `fileName` property will be used.
       */
      readonly documentTitle?: string | null
      /**
       * Additional context about the document that will be forwarded to the
       * large language model, but will not be used towards cited content.
       *
       * Useful for storing additional document metadata as text or stringified JSON.
       */
      readonly documentContext?: string | null
    } | null
  }

  export interface ToolCallPartOptions extends ProviderOptions {
    readonly anthropic?: {
      readonly caller?: {
        readonly type: string
        readonly toolId?: string | null
      } | null
      /**
       * Contains details about the MCP tool that was called.
       */
      readonly mcp_tool?: {
        /**
         * The name of the MCP server
         */
        readonly server: string
      } | null
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface ToolResultPartOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface ToolApprovalRequestPartOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface ToolApprovalResponsePartOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }

  export interface ToolApprovalResponsePartOptions extends ProviderOptions {
    readonly anthropic?: {
      /**
       * A breakpoint which marks the end of reusable content eligible for caching.
       */
      readonly cacheControl?: typeof Generated.CacheControlEphemeral.Encoded | null
    } | null
  }
}

declare module "effect/unstable/ai/Response" {
}

// =============================================================================
// Language Model
// =============================================================================

/**
 * @since 1.0.0
 * @category constructors
 */
export const model = (
  model: (string & {}) | Model,
  config?: Omit<typeof Config.Service, "model">
): AiModel.Model<"anthropic", LanguageModel.LanguageModel, AnthropicClient> =>
  AiModel.make("anthropic", layer({ model, config }))

/**
 * Creates an Anthropic language model service.
 *
 * @since 1.0.0
 * @category constructors
 */
export const make = Effect.fnUntraced(function*({ model, config: providerConfig }: {
  readonly model: (string & {}) | Model
  readonly config?: Omit<typeof Config.Service, "model"> | undefined
}): Effect.fn.Return<LanguageModel.Service, never, AnthropicClient> {
  const client = yield* AnthropicClient

  const makeConfig = Effect.gen(function*() {
    const services = yield* Effect.services<never>()
    return Config.of({
      model,
      ...providerConfig,
      ...services.mapUnsafe.get(Config.key)
    })
  })

  const makeRequest = Effect.fnUntraced(
    function*<Tools extends ReadonlyArray<Tool.Any>>({ config, options, toolNameMapper }: {
      readonly config: typeof Config.Service
      readonly options: LanguageModel.ProviderOptions
      readonly toolNameMapper: Tool.NameMapper<Tools>
    }) {
      const betas = new Set<string>()
      const messages = yield* prepareMessages({
        betas,
        config,
        options,
        toolNameMapper
      })
    }
  )

  return LanguageModel.LanguageModel.of({})
})

/**
 * Creates a layer for the OpenAI language model.
 *
 * @since 1.0.0
 * @category layers
 */
export const layer = (options: {
  readonly model: (string & {}) | Model
  readonly config?: Omit<typeof Config.Service, "model"> | undefined
}): Layer.Layer<LanguageModel.LanguageModel, never, AnthropicClient> =>
  Layer.effect(LanguageModel.LanguageModel, make(options))

/**
 * Provides config overrides for OpenAI language model operations.
 *
 * @since 1.0.0
 * @category configuration
 */
export const withConfigOverride: {
  (overrides: typeof Config.Service): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Config>>
  <A, E, R>(self: Effect.Effect<A, E, R>, overrides: typeof Config.Service): Effect.Effect<A, E, Exclude<R, Config>>
} = dual<
  (
    overrides: typeof Config.Service
  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Config>>,
  <A, E, R>(self: Effect.Effect<A, E, R>, overrides: typeof Config.Service) => Effect.Effect<A, E, Exclude<R, Config>>
>(2, (self, overrides) =>
  Effect.flatMap(
    Effect.serviceOption(Config),
    (config) =>
      Effect.provideService(self, Config, {
        ...(config._tag === "Some" ? config.value : {}),
        ...overrides
      })
  ))

// =============================================================================
// Prompt Conversion
// =============================================================================

const prepareMessages = Effect.fnUntraced(
  function*<Tools extends ReadonlyArray<Tool.Any>>({ betas, config, options, toolNameMapper }: {
    readonly betas: Set<string>
    readonly config: typeof Config.Service
    readonly options: LanguageModel.ProviderOptions
    readonly toolNameMapper: Tool.NameMapper<Tools>
  }) {
    const groups = groupMessages(options.prompt)

    let system: Array<typeof Generated.BetaRequestTextBlock.Encoded> | undefined = undefined
    const messages: Array<typeof Generated.BetaInputMessage.Encoded> = []

    for (let i = 0; i < groups.length; i++) {
      const group = groups[i]
      const isLastGroup = i === groups.length - 1

      switch (group.type) {
        case "system": {
          system = group.messages.map((message) => ({
            type: "text",
            text: message.content,
            cache_control: getCacheControl(message)
          }))
          break
        }

        case "user": {
          const content: Array<typeof Generated.BetaInputContentBlock.Encoded> = []

          for (const message of group.messages) {
            switch (message.role) {
              case "user": {
                for (let j = 0; j < message.content.length; j++) {
                  const part = message.content[j]
                  const isLastPart = j === message.content.length - 1

                  // Attempt to get the cache control from the part first. If
                  // the part does not have cache control defined and we are
                  // evaluating the last part for this message, also check the
                  // message for cache control.
                  const cacheControl = getCacheControl(part) ?? (
                    isLastPart ? getCacheControl(message) : null
                  )

                  switch (part.type) {
                    case "text": {
                      content.push({
                        type: "text",
                        text: part.text,
                        cache_control: cacheControl
                      })
                      break
                    }

                    case "file": {
                      if (part.mediaType.startsWith("image/")) {
                        const mediaType: typeof Generated.Base64ImageSource.Type["media_type"] =
                          (part.mediaType === "image/*" ? "image/jpeg" : part.mediaType) as any

                        const source = isUrlData(part.data)
                          ? { type: "url", url: getUrlString(part.data) } as const
                          : { type: "base64", media_type: mediaType, data: Base64.encode(part.data) } as const

                        content.push({ type: "image", source, cache_control: cacheControl })
                      } else if (part.mediaType === "application/pdf" || part.mediaType === "text/plain") {
                        betas.add("pdfs-2024-09-25")

                        const enableCitations = shouldEnableCitations(part)
                        const documentOptions = getDocumentMetadata(part)

                        const source = isUrlData(part.data)
                          ? {
                            type: "url",
                            url: getUrlString(part.data)
                          } as const
                          : part.mediaType === "application/pdf"
                          ? {
                            type: "base64",
                            media_type: "application/pdf",
                            data: typeof part.data === "string" ? part.data : Base64.encode(part.data)
                          } as const
                          : {
                            type: "text",
                            media_type: "text/plain",
                            data: typeof part.data === "string" ? part.data : Base64.encode(part.data)
                          } as const

                        content.push({
                          type: "document",
                          source,
                          title: documentOptions?.title ?? part.fileName ?? null,
                          cache_control: cacheControl,
                          ...(documentOptions?.context ? { context: documentOptions.context } : undefined),
                          ...(enableCitations ? { citations: { enabled: true } } : undefined)
                        })
                      } else {
                        return yield* new AiError.AiError({
                          module: "AnthropicLanguageModel",
                          method: "prepareMessages",
                          reason: new AiError.InvalidUserInputError({
                            description: `Detected unsupported media type for file: '${part.mediaType}'`
                          })
                        })
                      }

                      break
                    }
                  }
                }
                break
              }

              case "tool": {
                for (let j = 0; j < message.content.length; j++) {
                  const part = message.content[j]

                  // Skip evaluation of tool approval parts
                  if (part.type === "tool-approval-response") {
                    continue
                  }

                  const isLastPart = j === message.content.length - 1

                  // Attempt to get the cache control from the part first. If
                  // the part does not have cache control defined and we are
                  // evaluating the last part for this message, also check the
                  // message for cache control.
                  const cacheControl = getCacheControl(part) ?? (
                    isLastPart ? getCacheControl(message) : null
                  )

                  content.push({
                    type: "tool_result",
                    tool_use_id: part.id,
                    content: JSON.stringify(part.result),
                    is_error: part.isFailure,
                    cache_control: cacheControl
                  })
                }
              }
            }
          }

          messages.push({ role: "user", content })

          break
        }

        case "assistant": {
          const content: Array<typeof Generated.BetaContentBlock.Encoded> = []
          const mcpToolIds = new Set<string>()

          for (let j = 0; j < group.messages.length; j++) {
            const message = group.messages[j]
            const isLastMessage = j === group.messages.length - 1

            for (let k = 0; k < message.content.length; k++) {
              const part = message.content[k]

              if (part.type === "file" || part.type === "tool-approval-request") {
                continue
              }

              const isLastPart = k === message.content.length - 1

              // Attempt to get the cache control from the part first. If
              // the part does not have cache control defined and we are
              // evaluating the last part for this message, also check the
              // message for cache control.
              const cacheControl = getCacheControl(part) ?? (
                isLastPart ? getCacheControl(message) : undefined
              )

              switch (part.type) {
                case "text": {
                  content.push({
                    type: "text",
                    // Anthropic does not allow trailing whitespace in assistant
                    // content blocks
                    text: isLastGroup && isLastMessage && isLastPart
                      ? part.text.trim()
                      : part.text
                  })
                  break
                }
                case "reasoning": {
                  // TODO: make sending reasoning configurable
                  const info = part.options.anthropic?.info
                  if (Predicate.isNotNullish(info)) {
                    if (info.type === "thinking") {
                      content.push({
                        type: "thinking",
                        thinking: part.text,
                        signature: info.signature
                      })
                    } else {
                      content.push({
                        type: "redacted_thinking",
                        data: info.redactedData
                      })
                    }
                  }
                  break
                }

                case "tool-call": {
                  if (part.providerExecuted) {
                    const toolName = toolNameMapper.getProviderName(part.name)

                    const isMcpTool = Predicate.isNotNullish(part.options.anthropic?.mcp_tool)

                    if (isMcpTool) {
                      const { server } = part.options.anthropic.mcp_tool

                      mcpToolIds.add(part.id)

                      content.push({
                        type: "mcp_tool_use",
                        id: part.id,
                        name: part.name,
                        input: part.params as any,
                        server_name: server
                      })
                    } else if (
                      toolName === "code_execution" &&
                      Predicate.hasProperty(part.params, "type") &&
                      (
                        part.params.type === "bash_code_execution" ||
                        part.params.type === "text_editor_code_execution"
                      )
                    ) {
                      content.push({
                        type: "server_tool_use",
                        id: part.id,
                        name: part.params.type,
                        input: part.params as any
                      })
                    } else if (
                      // code execution 20250825 programmatic tool calling:
                      // Strip the fake 'programmatic-tool-call' type before sending to Anthropic
                      toolName === "code_execution" &&
                      Predicate.hasProperty(part.params, "type") &&
                      part.params.type === "programmatic-tool-call"
                    ) {
                      const { type, ...params } = part.params
                      content.push({
                        type: "server_tool_use",
                        id: part.id,
                        name: toolName,
                        input: params as any
                      })
                    } else {
                      if (
                        // code execution 20250522
                        toolName === "code_execution" ||
                        toolName === "tool_search_tool_regex" ||
                        toolName === "tool_search_tool_bm25" ||
                        toolName === "web_fetch" ||
                        toolName === "web_search"
                      ) {
                        content.push({
                          type: "server_tool_use",
                          id: part.id,
                          name: toolName,
                          input: part.params as any
                        })
                      }
                    }
                  } else {
                    // Extract caller info from provider options for programmatic tool calling
                    const options = part.options.anthropic
                    const caller = Predicate.isNotNullish(options?.caller)
                      ? (
                          options.caller.type === "code_execution_20250825" &&
                          Predicate.isNotNullish(options.caller.toolId)
                        )
                        ? {
                          type: "code_execution_20250825",
                          tool_id: options.caller.toolId
                        } as const
                        : options.caller.type === "direct"
                        ? {
                          type: "direct"
                        } as const
                        : undefined
                      : undefined

                    content.push({
                      type: "tool_use",
                      id: part.id,
                      name: part.name,
                      input: part.params as any,
                      ...(Predicate.isNotUndefined(caller) ? { caller } : undefined)
                    })
                  }

                  break
                }

                case "tool-result": {
                  const toolName = toolNameMapper.getProviderName(part.name)

                  if (mcpToolIds.has(part.id)) {
                    content.push({
                      type: "mcp_tool_result",
                      tool_use_id: part.id,
                      is_error: part.isFailure,
                      content: part.result as any
                    })
                    break
                  }

                  if (toolName === "code_execution") {
                    // TODO(Max): implement
                    //   const output = part.output;
                    //
                    //   // Handle error types for code_execution tools (e.g., from programmatic tool calling)
                    //   if (
                    //     output.type === 'error-text' ||
                    //     output.type === 'error-json'
                    //   ) {
                    //     let errorInfo: { type?: string; errorCode?: string } = {};
                    //     try {
                    //       if (typeof output.value === 'string') {
                    //         errorInfo = JSON.parse(output.value);
                    //       } else if (
                    //         typeof output.value === 'object' &&
                    //         output.value !== null
                    //       ) {
                    //         errorInfo = output.value as typeof errorInfo;
                    //       }
                    //     } catch {}
                    //
                    //     if (errorInfo.type === 'code_execution_tool_result_error') {
                    //       anthropicContent.push({
                    //         type: 'code_execution_tool_result',
                    //         tool_use_id: part.toolCallId,
                    //         content: {
                    //           type: 'code_execution_tool_result_error' as const,
                    //           error_code: errorInfo.errorCode ?? 'unknown',
                    //         },
                    //         cache_control: cacheControl,
                    //       }); } else { anthropicContent.push({
                    //         type: 'bash_code_execution_tool_result',
                    //         tool_use_id: part.toolCallId,
                    //         cache_control: cacheControl,
                    //         content: {
                    //           type: 'bash_code_execution_tool_result_error' as const,
                    //           error_code: errorInfo.errorCode ?? 'unknown',
                    //         },
                    //       });
                    //     }
                    //     break;
                    //   }
                    //
                    //   if (output.type !== 'json') {
                    //     warnings.push({
                    //       type: 'other',
                    //       message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`,
                    //     });
                    //
                    //     break;
                    //   }
                    //
                    //   if (
                    //     output.value == null ||
                    //     typeof output.value !== 'object' ||
                    //     !('type' in output.value) ||
                    //     typeof output.value.type !== 'string'
                    //   ) {
                    //     warnings.push({
                    //       type: 'other',
                    //       message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`,
                    //     });
                    //     break;
                    //   }
                    //
                    //   // to distinguish between code execution 20250522 and 20250825,
                    //   // we check if a type property is present in the output.value
                    //   if (output.value.type === 'code_execution_result') {
                    //     // code execution 20250522
                    //     const codeExecutionOutput = await validateTypes({
                    //       value: output.value,
                    //       schema: codeExecution_20250522OutputSchema,
                    //     });
                    //
                    //     anthropicContent.push({
                    //       type: 'code_execution_tool_result',
                    //       tool_use_id: part.toolCallId,
                    //       content: {
                    //         type: codeExecutionOutput.type,
                    //         stdout: codeExecutionOutput.stdout,
                    //         stderr: codeExecutionOutput.stderr,
                    //         return_code: codeExecutionOutput.return_code,
                    //         content: codeExecutionOutput.content ?? [],
                    //       },
                    //       cache_control: cacheControl,
                    //     });
                    //   } else {
                    //     // code execution 20250825
                    //     const codeExecutionOutput = await validateTypes({
                    //       value: output.value,
                    //       schema: codeExecution_20250825OutputSchema,
                    //     });
                    //
                    //     if (codeExecutionOutput.type === 'code_execution_result') {
                    //       // Programmatic tool calling result - same format as 20250522
                    //       anthropicContent.push({
                    //         type: 'code_execution_tool_result',
                    //         tool_use_id: part.toolCallId,
                    //         content: {
                    //           type: codeExecutionOutput.type,
                    //           stdout: codeExecutionOutput.stdout,
                    //           stderr: codeExecutionOutput.stderr,
                    //           return_code: codeExecutionOutput.return_code,
                    //           content: codeExecutionOutput.content ?? [],
                    //         },
                    //         cache_control: cacheControl,
                    //       });
                    //     } else if (
                    //       codeExecutionOutput.type ===
                    //         'bash_code_execution_result' ||
                    //       codeExecutionOutput.type ===
                    //         'bash_code_execution_tool_result_error'
                    //     ) {
                    //       anthropicContent.push({
                    //         type: 'bash_code_execution_tool_result',
                    //         tool_use_id: part.toolCallId,
                    //         cache_control: cacheControl,
                    //         content: codeExecutionOutput,
                    //       });
                    //     } else {
                    //       anthropicContent.push({
                    //         type: 'text_editor_code_execution_tool_result',
                    //         tool_use_id: part.toolCallId,
                    //         cache_control: cacheControl,
                    //         content: codeExecutionOutput,
                    //       });
                    //     }
                    //   }
                    //   break;
                    break
                  }

                  if (toolName === "web_fetch") {
                    content.push({
                      type: "web_fetch_tool_result",
                      tool_use_id: part.id,
                      content: part.result as any
                    })
                    break
                  }

                  if (toolName === "web_search") {
                    content.push({
                      type: "web_search_tool_result",
                      tool_use_id: part.id,
                      content: part.result as any
                    })
                    break
                  }

                  if (
                    toolName === "tool_search_tool_regex" ||
                    toolName === "tool_search_tool_bm25"
                  ) {
                    content.push({
                      type: "tool_search_tool_result",
                      tool_use_id: part.id,
                      content: part.result as any
                    })
                    break
                  }

                  break
                }
              }
            }
          }

          messages.push({ role: "assistant", content })

          break
        }
      }
    }

    return {
      system,
      messages
    }
  }
)

// =============================================================================
// Internal Utilities
// =============================================================================

type ContentGroup = SystemMessageGroup | AssistantMessageGroup | UserMessageGroup

interface SystemMessageGroup {
  readonly type: "system"
  readonly messages: Array<Prompt.SystemMessage>
}

interface AssistantMessageGroup {
  readonly type: "assistant"
  readonly messages: Array<Prompt.AssistantMessage>
}

interface UserMessageGroup {
  readonly type: "user"
  readonly messages: Array<Prompt.ToolMessage | Prompt.UserMessage>
}

const groupMessages = (prompt: Prompt.Prompt): Array<ContentGroup> => {
  const messages: Array<ContentGroup> = []
  let current: ContentGroup | undefined = undefined
  for (const message of prompt.content) {
    switch (message.role) {
      case "system": {
        if (current?.type !== "system") {
          current = { type: "system", messages: [] }
          messages.push(current)
        }
        current.messages.push(message)
        break
      }
      case "assistant": {
        if (current?.type !== "assistant") {
          current = { type: "assistant", messages: [] }
          messages.push(current)
        }
        current.messages.push(message)
        break
      }
      case "tool":
      case "user": {
        if (current?.type !== "user") {
          current = { type: "user", messages: [] }
          messages.push(current)
        }
        current.messages.push(message)
        break
      }
    }
  }
  return messages
}

/**
 * Checks if data is a URL (either a URL object or a URL string).
 */
const isUrlData = (
  data: typeof Prompt.FilePart.Type["data"]
): data is URL => data instanceof URL || isUrlString(data)

const isUrlString = (data: typeof Prompt.FilePart.Type["data"]): boolean =>
  typeof data === "string" && /^https?:\/\//i.test(data)

const getUrlString = (data: string | URL): string => data instanceof URL ? data.toString() : data

const shouldEnableCitations = (part: Prompt.FilePart): boolean => part.options.anthropic?.citations?.enabled ?? false

const getCacheControl = (
  part:
    | Prompt.SystemMessage
    | Prompt.UserMessage
    | Prompt.AssistantMessage
    | Prompt.ToolMessage
    | Prompt.UserMessagePart
    | Prompt.AssistantMessagePart
    | Prompt.ToolMessagePart
): typeof Generated.CacheControlEphemeral.Encoded | null => part.options.anthropic?.cacheControl ?? null

const getDocumentMetadata = (part: Prompt.FilePart): {
  readonly title: string | null
  readonly context: string | null
} | null => {
  const options = part.options.anthropic
  if (Predicate.isNotUndefined(options)) {
    return {
      title: options?.documentTitle ?? null,
      context: options?.documentContext ?? null
    }
  }
  return null
}
